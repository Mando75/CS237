#+TITLE: Weekly Assignment 03
#+LANGUAGE: en
#+OPTIONS: H:4 num:nil toc:nil \n:nil @:t ::t |:t ^:t *:t TeX:t LaTeX:t
#+STARTUP: showeverything
#+SCORE: 100

#+BEGIN: clocktable :maxlevel 2 :scope file
#+CAPTION: Clock summary at [2018-02-03 Sat 11:48]
| Headline                                |    Time |      |
|-----------------------------------------+---------+------|
| *Total time*                            | *14:06* |      |
|-----------------------------------------+---------+------|
| Study this Function and its...          |    4:34 |      |
| Probe Deeply Into A Number-Theoretic... |    2:13 |      |
| DEF [57/57]                             |    5:09 |      |
| \_  TBD                                 |         | 0:08 |
| \_  WDT                                 |         | 0:02 |
| \_  TDR                                 |         | 0:02 |
| \_  WDT                                 |         | 0:04 |
| \_  TEH                                 |         | 0:01 |
| \_  WFC                                 |         | 0:02 |
| \_  TEJ                                 |         | 0:01 |
| \_  WFK                                 |         | 0:02 |
| \_  TER                                 |         | 0:01 |
| \_  WGP                                 |         | 0:01 |
| \_  TEU                                 |         | 1:00 |
| \_  WJS                                 |         | 0:01 |
| \_  WKC                                 |         | 0:01 |
| \_  WKM                                 |         | 0:03 |
| \_  TIW                                 |         | 0:01 |
| \_  WNW                                 |         | 0:01 |
| \_  WOV                                 |         | 0:03 |
| \_  TME                                 |         | 0:02 |
| \_  WQW                                 |         | 0:01 |
| \_  TMZ                                 |         | 0:51 |
| \_  WRA                                 |         | 0:08 |
| \_  TNQ                                 |         | 0:01 |
| \_  WRP                                 |         | 0:01 |
| \_  TOJ                                 |         | 0:02 |
| \_  WRU                                 |         | 0:02 |
| \_  TOL                                 |         | 0:01 |
| \_  WZO                                 |         | 0:02 |
| \_  TOU                                 |         | 0:04 |
| \_  WYH                                 |         | 0:10 |
| \_  TLI                                 |         | 0:02 |
| \_  WPI                                 |         | 0:01 |
| \_  TSD                                 |         | 0:03 |
| \_  WTM                                 |         | 0:01 |
| \_  TTV                                 |         | 0:03 |
| \_  WUZ                                 |         | 1:33 |
| \_  TUK                                 |         | 0:01 |
| \_  WVQ                                 |         | 0:03 |
| \_  TUQ                                 |         | 0:02 |
| \_  WVU                                 |         | 0:01 |
| \_  TUW                                 |         | 0:01 |
| \_  WWD                                 |         | 0:10 |
| \_  TVL                                 |         | 0:01 |
| \_  WWR                                 |         | 0:02 |
| \_  TWN                                 |         | 0:01 |
| \_  WWS                                 |         | 0:01 |
| \_  WZG                                 |         | 0:02 |
| \_  TKH                                 |         | 0:01 |
| \_  WUE                                 |         | 0:01 |
| Day 1                                   |    0:08 |      |
| Day 3                                   |    1:36 |      |
| Day 4                                   |    0:26 |      |
#+END:


  In addition to all the section DEF exercises/problems/puzzles (EPPs) that you
  did /not/ do in DM1 (see [[file:../week00/schedule.org][schedule]]), please do the following tasks:

* DONE Study this Function and its Implementation in C++
  CLOSED: [2018-02-03 Sat 11:48]
  :LOGBOOK:
  CLOCK: [2018-02-03 Sat 11:06]--[2018-02-03 Sat 11:48] =>  0:42
  CLOCK: [2018-02-02 Fri 17:46]--[2018-02-02 Fri 18:53] =>  1:07
  CLOCK: [2018-02-01 Thu 17:03]--[2018-02-01 Thu 18:13] =>  1:10
  CLOCK: [2018-01-29 Mon 19:33]--[2018-01-29 Mon 20:05] =>  0:32
  CLOCK: [2018-01-24 Wed 15:15]--[2018-01-24 Wed 16:18] =>  1:03
  :END:

#+BEGIN_EXAMPLE
   The function f : Z+  x  Z+ --> Z+, where f(m, n) = [(m + n - 2)(m + n - 1)/2] + m,
   is one-to-one and onto.

   A little experimentation with this function shows the pattern.

   f(1,1) =  1   f(2,1) =  3   f(3,1) =  6   f(4,1) = 10   f(5,1) = 15

   f(1,2) =  2   f(2,2) =  5   f(3,2) =  9   f(4,2) = 14   f(5,2) = 20

   f(1,3) =  4   f(2,3) =  8   f(3,3) = 13   f(4,3) = 19   f(5,3) = 26

   f(1,4) =  7   f(2,4) = 12   f(3,4) = 18   f(4,4) = 25

   f(1,5) = 11   f(2,5) = 17   f(3,5) = 24

   f(1,6) = 16   f(2,6) = 23

   f(1,7) = 22

   It should be clear that the range of values this function takes on
   for a fixed value of m + n, say m + n = x, is

   (x - 2)(x - 1)                (x - 2)(x - 1)
   --------------  + 1  through  -------------- + (x - 1)
          2                             2

   since m can assume the values 1, 2, 3,...,(x - 1) under these
   conditions, and the first term in the formula is a fixed positive
   integer when m + n is fixed.

   To show that this function is one-to-one and onto, we merely need
   to show that the range of values for x + 1 picks up precisely
   where the range of values for x left off, i.e., that

   f(x - 1, 1) + 1 = f(1, x)

                     (x - 2)(x - 1)
   f(x - 1, 1) + 1 = -------------- + (x - 1) + 1
                            2

                     x^2 - x + 2    (x - 1)x
                   = -----------  = --------  + 1  = f(1, x)
                         2             2
#+END_EXAMPLE

#+BEGIN_SRC C++ :results output :var global_y=25
  #include <cmath>
  #include <cstdlib>
  #include <iostream>
  using namespace std;

  int f(int m, int n)
  {
     int x = m + n;
     return (((x - 2) * (x - 1) / 2) + m);
  }

  void invert(int y, int& m, int& n)
  {
     int x = ceil((3 + sqrt(8*y + 1))/2 ) - 1;
     m = y - ((x-1)*(x-2)/2);
     n = x - m;
  }

  int main(int argc, char* argv[])
  {
     int y = (argc > 1) ? atoi(argv[1]) : global_y;

     int m = 0;
     int n = 0;
     invert(y, m, n);
     // check answer
     if (y == f(m, n))
     {
     cout << "m = " << m << ", n = " << n << endl;
     }
     return 0;
  }
#+END_SRC

#+RESULTS:
: m = 4, n = 4

** My Work

*** Basic Equations
    We know that:

  1.  x = \lceil (3 + \radic(8y+1))/2 \rceil - 1
   
  2.  m = y - ((x - 1)(x-2))/2

  3.  n = x - m

*** Solving using the Quadratic Equation
    
    
**** Attempt 1
     Rearrange equation 2:
    
     y = (x - 2)(x - 1)/2 + m

     2y = (x -2)(x - 1) + 2m

     Solve for M Using equation 3:
         
            x = m + n \rarr 
            m = x - n 
            let n = 1 \rarr 
            m = x - 1

     Substitute that for m:

     2y = (x^2 - 3x + 2) + 2x - 2

     2y = x^2 - x 

     Make a quadratic:

     0 = x^2 - x - 2y

        a = 1
        b = -1
        c = -2y

     x = (1 + \radic(1 + 8y))/2

    
**** Alternatively, if you do not substitute, you can end up with this:
     x = (3 + \radic(8y + 1 -8m))/2 
     
     If we let m = 3, then we get the following: 

     x = (3 + \radic(81))/2 = 12/2 = 6 

     Then using the equation x = m + n, with m = 3 and x = 6, n = 3.

     What if we tried it with other values for m but applied the ceiling function?

#+BEGIN_SRC emacs-lisp :results silent
(defun test-function (y m) 
 (loop for i from 0 to m
    collect (- (ceiling (/ (+ 3 (sqrt (+ (* 8 y) (- 1 (* 8 i))))) 2)) 1)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (test-function 13 3)
#+END_SRC

#+RESULTS:
| 6 | 6 | 6 | 5 |

   So it looks like if the assumed value of m is less than the actual m, we can compensate for it by applying 
   the cieling function and subtracting 1. Lets try this with some other inputs as well. 

#+BEGIN_SRC emacs-lisp
  (test-function 25 4)

  ;; With these inputs of m = 4 and n = 4, with f(m,n) = 25 
  ;; x should equal 8. So if I am correct, we should get an output
  ;; of (8 8 8 8 7). The function will produce the correct output for 
  ;; each 'assumed' value of m while i < m
#+END_SRC

#+RESULTS:
| 8 | 8 | 8 | 8 | 7 |

This is quite interesting. You are able to eliminate the m variable completely from the equation
by assuming that m = 0, applying the ceiling function and subtracting 1. As long as the assumed value of 
m is the actual correct value, we will still get the correct resulting x. 

* DONE Probe Deeply Into A Number-Theoretic Conjecture
  CLOSED: [2018-02-01 Thu 19:45]
  :LOGBOOK:
  CLOCK: [2018-02-01 Thu 19:14]--[2018-02-01 Thu 19:45] =>  0:31
  CLOCK: [2018-02-01 Thu 15:45]--[2018-02-01 Thu 16:14] =>  0:29
  CLOCK: [2018-01-31 Wed 19:31]--[2018-01-31 Wed 20:44] =>  1:13
  :END:

  Let us define two infinite sets of positive integers, /A/ and /B/, to be
  generated based on two real numbers. The first is \( x = \sqrt{2} \), so \( A
  = \{\lfloor x \rfloor, \lfloor 2x \rfloor, \lfloor 3x \rfloor, \lfloor 4x \rfloor, \ldots \} \), more succinctly written as \( \{\lfloor nx \rfloor : n
  \in \mathbf{Z^{+}}\} \). /B/ is similarly defined, except with \( 2 + \sqrt{2}
  \) being the real number /x/. So in words, /A/ is the set of all floored
  positive integer multiples of the square root of two. /B/ is the set of all
  floored positive integer multiples of two plus the square root of two.

  You must grasp the meaning of this definition and demonstrate that you have
  achieved a solid understanding of it. To help achieve and explore that
  understanding, write an elisp program to calculate the two sets /A/ and /B/.
  As you examine your results, be on the lookout for any patterns, and formulate
  some kind of conjecture about these results. State your conjecture clearly and
  unambiguously, then try to /verify/ your conjecture for as many positive
  integers as you can.

  In the supplied sample code is an elisp program (=3x+1conjecture.el=) that
  verifies the so-called /3x + 1 conjecture/ for a given positive integer. When
  you examine this code, note the use of the calc package and how it enables
  working with /very large/ numbers.

** My Work
   
*** Functions to create set entries
 #+BEGIN_SRC emacs-lisp :results silent
   (defun create-A-entry (x)
      (floor (* x (sqrt 2.0))))

   (defun create-B-entry (x)
      (floor (* x (+ 2 (sqrt 2.0)))))
 #+END_SRC

*** Compare subset entries
 Create a small subset of A

 #+BEGIN_SRC emacs-lisp
   (setq set-A (mapcar 'create-A-entry (number-sequence 1 25)))
 #+END_SRC

 #+RESULTS:
 | 1 | 2 | 4 | 5 | 7 | 8 | 9 | 11 | 12 | 14 | 15 | 16 | 18 | 19 | 21 | 22 | 24 | 25 | 26 | 28 | 29 | 31 | 32 | 33 | 35 |



 Create a small subset of B
 #+BEGIN_SRC emacs-lisp
  (setq set-B (mapcar 'create-B-entry (number-sequence 1 10)))
 #+END_SRC

 #+RESULTS:
 | 3 | 6 | 10 | 13 | 17 | 20 | 23 | 27 | 30 | 34 |

*** Initial conclusions

    If we compare the first 25 elements of set A with the first 10 elements of set B, we can see some interesting patterns.
    
    A \cup B gives us every positive integer up until 35

#+BEGIN_SRC emacs-lisp
  (sort (-union set-A set-B) #'<)
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 |


  The intersection is the empty set

#+BEGIN_SRC emacs-lisp :results raw
  (-intersection set-A set-B)
#+END_SRC

#+RESULTS:
nil
 
*** Form a conjecture...
   Theoretically, if the above pattern holds, we could generate the entire set of positive integers using the union of A and B.
   Interestingly enough, if the above pattern holds, no matter how large we let sets A and B grow, their intersection will always be the empty set.
   Of course, we would never be able to fully construct either set (they are infinite), but we could test this property on some seemingly large (for us) sets.

   The intersection is disjoint, and the union contains all real positive integers with now repeats.

*** Testing
**** Attempt 1
 #+BEGIN_SRC emacs-lisp :results silent
   (defun testing-conjecture (max)
    (let ((test-list '())
          (errs 0))       
      (loop for i from 1 to max   
          do (setq test-list (append test-list (list (create-A-entry i)) (list (create-B-entry i))))
          do (if (member i test-list) (delete (position i test-list) test-list) (incf errs)))
      (list 'errs errs 'list test-list)
   ))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
   (testing-conjecture 100)
 #+END_SRC 

 #+RESULTS:
 | errs | 0 | list | (1 75 78 81 85 88 92 95 99 102 105 109 112 116 119 122 126 129 133 136 139 143 146 150 153 157 160 163 167 170 72 174 73 177 74 180 76 184 77 187 79 191 80 194 82 198 83 201 84 204 86 208 87 211 89 215 90 218 91 221 93 225 94 228 96 232 97 235 98 238 100 242 101 245 103 249 104 252 106 256 107 259 108 262 110 266 111 269 113 273 114 276 115 279 117 283 118 286 120 290 121 293 123 297 124 300 125 303 127 307 128 310 130 314 131 317 132 320 134 324 135 327 137 331 138 334 140 338 141 341) |

**** Attempt 2

I believe that this function demonstrates that the conjecture is true, at least up until a million (what I tested)
The process is simple enough. We create two counters, one for set a, one for set b. We increment an index i from
1 to the max. We check to see if when we pass the counter to the A set, if it equals the index. If it does, we increment
the counter and go again. If it does not, we try with B. If b fails, it prints an error.
This ensures that ever number between 1 and the max is accounted for, and if any are missed, an error is thrown. 
This tests the Union of set A and set B.

#+BEGIN_SRC emacs-lisp :results output
(defun attempt-2 (max)
"A function to test my conjecture"
 (let ((countera 1)
       (counterb 1))         
    (loop for i from 1 to max
     do (cond ((= (create-A-entry countera) i) (incf countera))
              ((= (create-B-entry counterb) i) (incf counterb))
              (t (print "error"))))))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp :results output
  (attempt-2 1000000)
#+END_SRC

#+RESULTS:

* Sample Code

#+BEGIN_SRC emacs-lisp :tangle 3x+1conjecture.el
  (require 'calc)

  (defmath is-odd (num)
    (= (logand num 1) 1))

  (defmath 3x+1 (num)
    (if (is-odd num)
        (1+ (* 3 num))
      (/ num 2)))

  (defmath transform-3x+1 (num)
    (while (> num 1)
      (setq num (3x+1 num)))
    num)

  (defun test-3x+1-conjecture (max-num)
    (loop for n from 2 to max-num
          unless (= 1 (calcFunc-transform-3x+1 n))
          collect n))

  (defmacro measure-time (&rest body)
    "Measure and return the running time of the code in body."
    (declare (indent defun))
    (let ((start (make-symbol "start")))
      `(let ((,start (float-time)))
         ,@body
         (- (float-time) ,start))))
#+END_SRC

#+RESULTS:
: measure-time

#+BEGIN_SRC emacs-lisp
  (require 'calc-math)
  (calcFunc-is-odd (math-read-number "3589723987598273598723958729385792875982735982759871"))
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC emacs-lisp
  (vector (measure-time (setq results (test-3x+1-conjecture 100000))) results)
#+END_SRC

#+RESULTS:
: [16.993004322052002 nil]



* DONE DEF [57/57]
  CLOSED: [2018-02-01 Thu 15:49]

  NOTE: I did these all in DM1. These are just pasted here for your pleasure :)

** DONE TBD
   CLOSED: [2018-01-29 Mon 20:13]
   :LOGBOOK:
   CLOCK: [2018-01-29 Mon 20:05]--[2018-01-29 Mon 20:13] =>  0:08
   :END:
   A function is injective if and only if is surjective, provided its domain and codomain 
   are the same size. 

   the function f : A \rarr B is bijective if and only if \forall b \in B there is a unique a \in A such that f(A) = B
    
** DONE WDT
   CLOSED: [2018-01-29 Mon 20:15]
    :LOGBOOK:
    CLOCK: [2018-01-29 Mon 20:13]--[2018-01-29 Mon 20:15] =>  0:02
    :END:
    
Variable immutibility is being flouted. In pure functional programming 'variables' shouldn't exist. All
objects, whether they be primitive types or higher order types, should be immutable. 

    #+BEGIN_SRC emacs-lisp
(require 'cl)
   (set 'a 'three) 
   (setq a (quote one)) ;; setq is equivalent to set, except instead of having to put a ' in front of the variable, it does it for you
   (setf b '(one two)) ;; setf is similar to setq, but it accepts forms on the left side instead of just symbols like (see the third example of setf)
   (setf a (first b)) ;; whenever you use setq, you could theoretically use setf, although stylisticly, setq is preferred for basic symbols. 
   (setf (second b) a)

(print a)

    #+END_SRC

    #+RESULTS:
    : one
    t
** DONE TDR
   CLOSED: [2018-01-29 Mon 20:18]
    :LOGBOOK:
    CLOCK: [2018-01-29 Mon 20:16]--[2018-01-29 Mon 20:18] =>  0:02
    :END:

A simple function that adds one to a number

#+BEGIN_SRC emacs-lisp :results silent
  (fset 'tdr (lambda (n) (+ 1 n)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (tdr 2)
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC emacs-lisp
(setf (symbol-function 'tdr-1) (lambda (n) (+ 1 n)))

(tdr-1 2)
#+END_SRC

#+RESULTS:
: 3

** DONE WDT
   CLOSED: [2018-01-29 Mon 20:23]
   :LOGBOOK:
   CLOCK: [2018-01-29 Mon 20:19]--[2018-01-29 Mon 20:23] =>  0:04
   :END:

   PVP = Predict Verify Ponder

*** Predict  

    1. I think the first expression will execute without a problem, returning the number 6.
    2. I think the second expression will have some trouble, because d is not defined.
    3. I think this will run into the same problem, because it is a vector.
    4. I don't believe that lisp supports operator overloading, so I believe the 4th will fail.
    5. I think that this expression will have trouble evaluating, because let process the expressions in parallel, and not sequentially.
    6. I think this should give a proper output of 1.
*** Verify/Ponder

**** Expression 1:
      #+BEGIN_SRC emacs-lisp
 (let ((a 1) (b 2) (c 3)) (+ a b c))
      #+END_SRC

      #+RESULTS:
      : 6
I successfully predicted the result.

**** Expression 2:
#+BEGIN_SRC emacs-lisp
  (let ((a 1) (b 2) (c 3)) (+ a b c d))
#+END_SRC

Returned an error saying that d was void

**** Expression 3: 
#+BEGIN_SRC emacs-lisp 
  (let ((a 1) (b 2) (c 3)) [+ a b c d])
#+END_SRC

#+RESULTS:
: [+ a b c d]

I was not expecting this, but I believe I understand why this happened. Reading this stack overflow post
helped me better understand how vectors work: https://stackoverflow.com/questions/4294346/difference-between-lists-and-arrays

Vectors are self-evaluating, so the let will just return the vector without evaluating it.
**** Expression 4: 
#+BEGIN_SRC emacs-lisp
  (let ((a 1) (b 2) (c 3) (+ 4)) (+ a b c +))
#+END_SRC

#+RESULTS:
: 10

I found this very interesting. I did not know that 1, you could redefine operators like that. A key point here though, 
if I am correct, it is not actually overloading the operator, but saying 'if you find a + that is not the first element in a list, 
evaluate it as 4'. That's why (+ a b c +) works. Lisp reads the first item as the function to call, and evaluates the second + as 
was previously defined. 

**** Expression 5: 
#+BEGIN_SRC emacs-lisp
  (makunbound 'a)
(let ((a 1) (b 2) (c 3) (d (+ a 4))) (+ a b c d))
#+END_SRC

This returned a message saying that a was void. I believe this is due to my reasoning above, 
but my knowledge of Lisp is not currently strong enough to be sure. 

**** Expression 6:
#+BEGIN_SRC emacs-lisp 
  (let* ((a 1) (b 2) (c 3) (d (+ a 4))) (+ a b c d))
#+END_SRC

#+RESULTS:
: 11

I successfully predicted the output for this.

** DONE TEH
   CLOSED: [2018-01-29 Mon 20:27]
   :LOGBOOK:
   CLOCK: [2018-01-29 Mon 20:26]--[2018-01-29 Mon 20:27] =>  0:01
   :END:
    I think that it would be possible. If you made sure to define variables before using them. Let's look at
    a modified version of the example code: 
#+BEGIN_SRC emacs-lisp
;; here's the original statement:
;;(let ((a 1) (b 2) (c 3) (d (+ a 4))) (+ a b c d))

;; let's try to change it up a bit
(let ((a 1) (b 2) (c 3))
   (let ((d (+ a 4))) (+ a b c d)))

;; I nested the let statement that defines d and adds all the variables together
;; inside the first let statement. This ensures that a is given a value before
;; trying to use it to initialize d
#+END_SRC

#+RESULTS:
: 11
** DONE WFC
   CLOSED: [2018-01-29 Mon 20:29]
   :LOGBOOK:
   CLOCK: [2018-01-29 Mon 20:27]--[2018-01-29 Mon 20:29] =>  0:02
   :END:

    They behave pretty much how I would expect them to. I haven't
    seen anything that raises an eyebrow. It was important to note that
    if you with to use a combination of operators, you must nest them inside
    parantheses. Here's an FLA for you, LISP: Lots of Irritating Single Parantheses ;)

    NOTE: While the above opinion was that of a new DM1 student who didn't fully appreciate Lisp at the time,
    I stand by the opinion that the syntax is not the /most/ readable progamming language. 

#+BEGIN_SRC emacs-lisp :results output
(progn (print (/ 24 4 3))
(print (* 5 4 3 2 1))
(print (* (+ 2 3) 2)))
#+END_SRC

#+RESULTS:
: 
: 2
: 
: 120
: 
: 10

Even with multiple operands, it behaves exactly as expected. It executes the operation in the order it was given. 
** DONE TEJ
   CLOSED: [2018-01-29 Mon 20:34]
   :LOGBOOK:
   CLOCK: [2018-01-29 Mon 20:33]--[2018-01-29 Mon 20:34] =>  0:01
   :END:

**** assoc-string
     when using assoc-string, the key must be a string or symbol.
    
   #+BEGIN_SRC emacs-lisp
  (defun lookup-rgb (color-name)
  (rest (assoc-string color-name
               '(("red" 255 0 0) ("green" 0 255 0) ("blue" 0 0 255)))))

  (lookup-rgb "green")
   #+END_SRC 

   #+RESULTS:
   | 0 | 255 | 0 |
**** rassoc
rassoc is like the reverse assoc. Instead of searching for the car, it matches the cdr
    #+BEGIN_SRC emacs-lisp
   (defun lookup-rgb (color-range)
  (rest (rassoc color-range
               '(("red" 255 0 0) ("green" 0 255 0) ("blue" 0 0 255)))))
;; Produces nil: 
;;(lookup-rgb '(0 255 3))
;; Produces the cdr 
   (lookup-rgb '(255 0 0))
    #+END_SRC 

    #+RESULTS:
    | 255 | 0 | 0 |
**** assq
assq is also similar to assoc, but it compares using eq insteal of equal.
Go here to read the difference: https://www.gnu.org/software/emacs/manual/html_node/elisp/Equality-Predicates.html#Equality-Predicates
assq is best used when the key is a symbol, not a string

#+BEGIN_SRC emacs-lisp
   (defun lookup-rgb (color-range)
  (rest (assq color-range
               '((red 255 0 0) (green 0 255 0) (blue 0 0 255))))) 
(lookup-rgb 'red)
#+END_SRC

#+RESULTS:
| 255 | 0 | 0 |
**** more
     There are several more variations of assoc. You can find them here: https://www.gnu.org/software/emacs/manual/html_node/elisp/Association-Lists.html
** DONE WFK
   CLOSED: [2018-01-29 Mon 20:36]
   :LOGBOOK:
   CLOCK: [2018-01-29 Mon 20:34]--[2018-01-29 Mon 20:36] =>  0:02
   :END:
Removing the :test 'equal changes the the contents of the pretty print list to nil, as eq does not work on string literals
#+BEGIN_SRC emacs-lisp :results output
(let* ((mymap (make-hash-table :test 'equal)))
  (puthash "one" "red" mymap)
  (puthash "two" "blue" mymap)
  (puthash "three" "green" mymap)
  (pp (list (gethash "one" mymap)
            (gethash "two" mymap)
            (gethash "three" mymap)))
  (maphash (lambda (key value) (princ (format "%s : %s\n" key value))) mymap))

#+END_SRC

#+RESULTS:
: ("red" "blue" "green")
: one : red
: two : blue
: three : green
** DONE TER
   CLOSED: [2018-01-29 Mon 20:42]
   :LOGBOOK:
   CLOCK: [2018-01-29 Mon 20:41]--[2018-01-29 Mon 20:42] =>  0:01
   :END:
**** Predict
     This looks similar to the map function in JavaScript, which is given an array, and executes a function
     on each element in the array. (See here for more info on JS map https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
     I would assume that morphify does something similar. Guessing from the function call to downcase, I think
     it will put each word as lowercase. 
**** Verify/Ponder
#+BEGIN_SRC emacs-lisp
(defun morphify (fun lst)
  (loop for item in lst
        collect (funcall fun item)))
(morphify (quote downcase) (quote ("THIS" "IS" "TOO" "LOUD")))
#+END_SRC

#+RESULTS:
| this | is | too | loud |
**** Part 2
#+BEGIN_SRC emacs-lisp
(defun morphifyr (fun lst)
  (if (null lst)
      nil
    (append (list (funcall fun (first lst))) (morphifyr fun (rest lst)))))

(morphifyr 'upcase '("1232142" "asdfasdf" "abcdefg"))
#+END_SRC

#+RESULTS:
| 1232142 | ASDFASDF | ABCDEFG |

First this function checks that there was a function passed to it. If not, it returns nil
Next it starts appending a list. The first element of this list is created by calling the passed function on the
car. It builds the rest of the list by calling morphify on the cdr. This recursively builds the list items and returns
a new list, thus keeping it functional!
** DONE WGP 
   CLOSED: [2018-01-29 Mon 20:43]
   :LOGBOOK:
   CLOCK: [2018-01-29 Mon 20:42]--[2018-01-29 Mon 20:43] =>  0:01
   :END:

Just use the example given in the miniprimer! Append an empty list to a vector to convert it to a list.

    #+BEGIN_SRC emacs-lisp
    (defun vector-to-string(vec)
      (append vec nil))

(format "%s" (vector-to-string [a b c]))

    #+END_SRC

    #+RESULTS:
    : (a b c)
** DONE TEU
   CLOSED: [2018-02-01 Thu 15:49]
   :LOGBOOK:
   CLOCK: [2018-01-29 Mon 20:45]--[2018-01-29 Mon 21:45] =>  1:00
   :END:

   17316
*** JavaScript
    So I did this in JavaScript. I will try to implement it in LISP
 #+BEGIN_SRC javascript
 // A function that counts solutions for a given predicate. 
 // Takes a max number of iterations, as well as a predicate. 
 // There is an optional third parameter, min, if you do not 
 // wish to start counting at zero
 function countSolutions(max, pred, min = 0) {
   let counter = 0;
   for (let i = min; i < max; i++) {
      pred(i) ? counter++ : null;
   }
   console.log("total",counter);
 }


 function teu_loops(i) {
   let val = i,
       sum = 0, 
       ones = 0;
  
   while (val) {
     if (ones > 1) {
       return false;
     }
     if (val % 10 === 1) {
       ones++;
     }
     sum += val % 10;
     val = Math.floor(val / 10);
   }
   if (sum != 17){
     return false;
   }
   return true;
 }
 countSolutions(1000000,teu_loops);
 #+END_SRC


 A non-looping solution
 #+BEGIN_SRC javascript
 const print = console.log

 // A function that counts solutions for a given predicate. 
 // Takes a starting, and max number, as well as a predicate. 
 // The function also takes a count of how many times the predicate
 // returns true. 
 function tellen(start, max, pred, tel=0) {
   if(start >= max) {
     return tel;
   }
   pred(start) ? tel++ : null;
   return tellen(start + 1, max, pred, tel)
 }

 function sumDigits(number) {
     var remainder = number % 10;
     var sum = remainder;
     if(number >= 10) {
         var rest = Math.floor(number / 10);
         sum += sumDigits(rest); 
     }
     return sum;
 }

 function lessThanOnes(number) {
   let str = number + '';
   if(str.split('1').length > 2) {
     return false;
   }
   return true;
 }

 function pred(i) {
   if(sumDigits(i) === 17 && lessThanOnes(i)) {
     return true;
   }
   return false;
 }


 print(tellen(0,1000000, pred));
 #+END_SRC
*** LISP

#+BEGIN_SRC emacs-lisp :results silent
(defun sum-of-digits(number) 
 (if (= number 0) 0 
    (+ (mod number 10) 
       (sum-of-digits (/ (- number (mod number 10)) 10)))))

(defun teu-loops (max)
   (loop for i from 0 to max
     sum (cond ((not (= (sum-of-digits i) 17))  0)
                ()))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (teu-loops '110)
#+END_SRC

#+RESULTS:
: 2

#+BEGIN_SRC emacs-lisp
(defun number-to-list (n)    
  (loop for c from 1 to (length (number-to-string n))
        with x = n
        collect (% x 10)
        ))

  (number-to-list 124)
#+END_SRC

#+RESULTS:
| 4 | 4 | 4 |

** DONE WGW
   CLOSED: [2018-01-29 Mon 21:49]

First it checks that pre is a list and that its length is three. 
Then is creates a variable for each operator, using the nth item in the list function.
To ensure that any nested operations are caught, the prefix->infix function is called again on 
each of the operands. 
    #+BEGIN_SRC emacs-lisp
 (defun prefix->infix (pre)
  (cond ((listp pre)
         (or (= 3 (length pre)) (error "not a 3-length list"))
         (let ((operator (nth 0 pre))
               (operand1 (nth 1 pre))
               (operand2 (nth 2 pre)))
           (list (prefix->infix operand1)
                 operator
                 (prefix->infix operand2))))
        (t pre)))   
(prefix->infix '(/ 1.0 (* (+ (* 2 n) 1) (expt -1 n))))
    #+END_SRC

    #+RESULTS:
    | 1.0 | / | (((2 * n) + 1) * (-1 expt n)) |

#+BEGIN_SRC emacs-lisp
(defun prefix->infix (pre)
   (if (listp pre)
     (if (= 3 (length pre)) 
        (list 
         (prefix->infix (nth 1 pre))
         (nth 0 pre)
         (prefix->infix (nth 2 pre)))
         (error "not a 3-length list"))
      (list pre)))

(prefix->infix ')(* (/ 12 4 )(+ 3 2))

#+END_SRC

#+RESULTS:
| ((12) / (4)) | * | ((3) + (2)) |
** DONE TFV
   CLOSED: [2018-01-29 Mon 21:50]
   :LOGBOOK:
   CLOCK: [2018-01-29 Mon 21:50]--[2018-01-29 Mon 21:50] =>  0:00
   :END:
#+BEGIN_SRC emacs-lisp
   
(defun infix->prefix (in)
       (cond ((listp in) (or (= 3 (length in)) (error "not a 3-length list"))
         (let ((operand1 (nth 0 in)) (operator (nth 1 in)) (operand2 (nth 2 in)))
                (list operator (infix->prefix operand1)
                 (infix->prefix operand2))))
        (t in)))
(infix->prefix '((3 * 7) + 4))
#+END_SRC

#+RESULTS:
| + | (* 3 7) | 4 |
** DONE WJS
   CLOSED: [2018-01-29 Mon 21:51]
   :LOGBOOK:
   CLOCK: [2018-01-29 Mon 21:50]--[2018-01-29 Mon 21:51] =>  0:01
   :END:

Because the floor function takes the largest integer less than or equal, and the number is negative, the next lowest integer will be -x - 1. In positive division, this is 
the same effect as integer division, because if there is a decimal remainder, it will be chopped off, leaving the next lowest integer. Because negative numbers are moving
the opposite direction, you can almost imagine floor and ceiling also get negated respectively. The floor of a negative x is the ceiling of the absolute value of x, and vice versa.
** DONE TGE
   CLOSED: [2018-01-29 Mon 21:51]
#+BEGIN_SRC emacs-lisp
(defun compute-floor-the-hard-way (dividend divisor)
  (- (/ dividend (float divisor)) (/ (mod dividend divisor) (float divisor))))

(let* ((number (/ -13 4.0))
       (floor1 (floor number))
       (floor2 (compute-floor-the-hard-way -13 4.0)))
  (list number floor1 floor2))
#+END_SRC

#+RESULTS:
| -3.25 | -4 | -4.0 |

I'm not sure exactly what is meant by 'correct', but the compute-floor-the-hard-way returns a floating point number, not an integer,
so one could make the argument that it is not correct, as floor should return an integer.    
** DONE WKC
   CLOSED: [2018-01-29 Mon 21:52]
   :LOGBOOK:
   CLOCK: [2018-01-29 Mon 21:51]--[2018-01-29 Mon 21:52] =>  0:01
   :END:
    #+BEGIN_SRC emacs-lisp 
  (defun frac-part (number)
  (- number (floor number)))

(print (frac-part 3.14159))

(defun floor2 (number)
"returns the floor of a number using the provided frac-part function defined above"
(truncate (- number (frac-part number))))

(print (floor2 3.14159))


#+END_SRC

#+RESULTS:
: 3
** DONE THP
   CLOSED: [2018-01-29 Mon 21:52]
   :LOGBOOK:
   CLOCK: [2018-01-29 Mon 21:52]--[2018-01-29 Mon 21:52] =>  0:00
   :END:

FLOOR
                 5
                    |              *--o
                    |           *--o
                    |        *--o
                    |     *--o 
                    |  *--o 
-5   ---------------*--o----------------5
                 *--o
              *--o  |
           *--o     |
        *--o        |
     *--o           |
                   -5

CEILING

                 5
                    |              o--*
                    |           o--*
                    |        o--*
                    |     o--* 
                    |  o--* 
-5   ---------------o--*----------------5
                 o--*
              o--*  |
           o--*     |
        o--*        |
     o--*           |
                   -5

** DONE WKM
   CLOSED: [2018-01-29 Mon 21:56]
   :LOGBOOK:
   CLOCK: [2018-01-29 Mon 21:53]--[2018-01-29 Mon 21:56] =>  0:03
   :END:
**** 1. True
**** 2. True
**** 3. False
**** 4. True
**** 5. True
**** 6. True
**** 7. True
**** 8. False
**** 9. True
**** 10. True
** DONE TIW
   CLOSED: [2018-01-29 Mon 21:57]
   :LOGBOOK:
   CLOCK: [2018-01-29 Mon 21:56]--[2018-01-29 Mon 21:57] =>  0:01
   :END:

#+BEGIN_SRC emacs-lisp
(defun frac-part (number)
  (- number (floor number)))

(defun round-nearest-int (number)
   (cond 
      ((< (frac-part number) .5) (floor number))
      (t (ceiling number))
   )
)   

(round-nearest-int '1.5624) 
    #+END_SRC

    #+RESULTS:
    : 2
** DONE WNW
   CLOSED: [2018-01-30 Tue 15:10]
   :LOGBOOK:
   CLOCK: [2018-01-30 Tue 15:09]--[2018-01-30 Tue 15:10] =>  0:01
   :END:
   An invertible function must be one-to-one. 
** DONE TKG
   CLOSED: [2018-01-30 Tue 15:10]
   :LOGBOOK:
   CLOCK: [2018-01-30 Tue 15:10]--[2018-01-30 Tue 15:10] =>  0:00
   :END:
#+BEGIN_SRC emacs-lisp 
 (setq values '((x . 100) (y . 200) (z . 50)))
 (assoc 'y values)
 (rassoc '100 values)
 
#+END_SRC 

#+RESULTS:
: (x . 100)

Assoc searches by key, rassoc searches by value
An associative list is a kind of hash mapping, where each value is given a key. This creates
a one-to-one relationship which is why assoc can be inverted with rassoc.

** DONE WOV
   CLOSED: [2018-01-30 Tue 15:13]
   :LOGBOOK:
   CLOCK: [2018-01-30 Tue 15:10]--[2018-01-30 Tue 15:13] =>  0:03
   :END:
   1. a, a + d, a +2d, a + 3d... where a = 7 d = 7
   2. a, a + d, a + 2d, a + 3d... where a = 7 d = 4
   3. a, a + d, a + (d + 1), a + (d + 2), a + (d + 3) where a = 3 d = 1
   4. it is binary addition, adding one each iteration starting with 1.
   5. Fibonacci, n = n - 1 + n - 2 where n is the index in the sequence
   6. Starting with index 2, every other number is half of the one previous. ****
   7. Alternative fibonacci pattern beginning with 2,1 instead of 1, 1
   8. multiply the last index by two to find the next entry in the sequence. Where n initial is 6
   9. multiply the last index by three to find the next entry in the sequence. Where n intial is 6
   10. A sequence of prime numbers
** DONE TME
   CLOSED: [2018-01-30 Tue 15:15]
   :LOGBOOK:
   CLOCK: [2018-01-30 Tue 15:13]--[2018-01-30 Tue 15:15] =>  0:02
   :END:

    This sequence is building the title of the book, Metaphors Be With You: 
    A Tireless Work On Play On Words. After 4 iterations, it adds a new letter
    to each item, spelling out the title.
    [metaph bewith youat irele metapho bewithy ouatir elessw] etc... 
** DONE WQW
   CLOSED: [2018-01-30 Tue 15:16]
   :LOGBOOK:
   CLOCK: [2018-01-30 Tue 15:15]--[2018-01-30 Tue 15:16] =>  0:01
   :END:
   | Predicate | Yes or No? |
   |-----------+------------|
   | list      | no         |
   | listp     | yes        |
   | integerp  | yes        |
   | vector    | no         |
   | vectorp   | yes        |
   | symbolp   | yes        |
   | zerop     | yes        |
   | evenp     | yes        |
   | oddp      | yes        |
   |           |            |
** DONE TMZ
   CLOSED: [2018-01-30 Tue 21:59]
   :LOGBOOK:
   CLOCK: [2018-01-30 Tue 16:00]--[2018-01-30 Tue 16:15] =>  0:15
   CLOCK: [2018-01-30 Tue 15:16]--[2018-01-30 Tue 15:52] =>  0:36
   :END:
**** 1.
 #+BEGIN_SRC emacs-lisp :results raw
 (require 'cl)

 (defun count-gcd (max pred)
 (let ((counter 0)))
 (loop for i from 1 to max 
    sum (loop for j from 1 to max
       count (funcall pred i j))))

 (count-gcd 1000 (lambda (m n) (= 1 (gcd m n))))
 #+END_SRC

 #+RESULTS:
 608383
**** 2.  
There are infinitly many solutions to this problem as given. ax + by = c is what is known as a 
Diophantine equation. One of the rules of these equations is that if c is a multiple of the gcd(a,b), than
there are is an infinite amount of solutions. 
For the given problem where a = 3, b =4 , c=7: 
#+BEGIN_SRC emacs-lisp :results raw
(gcd 3 4)
#+END_SRC 

#+RESULTS:
1

7 is a multiple of 1, therefore, this equation does have a solution (for example, x = 1, y = 1), but it also 
implies that there is an infinite set of solutions. See http://mathforum.org/library/drmath/view/51595.html for a more
detailed explanation. 
**** 3.
     :LOGBOOK:
     CLOCK: [2018-01-30 Tue 15:59]--[2018-01-30 Tue 15:59] =>  0:00
     :END:

#+BEGIN_SRC emacs-lisp :results silent
(defun loops-and-preds (set pred)
   (loop for i across set
         sum (loop for j across set
             sum (if (funcall pred i j) 1 0)
             do (if (funcall pred i j) (print (list t i j))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results output
  (loops-and-preds [2 3 4 5 6 7 8 9] (lambda (i j) (= (% (- (* i j) 1) 11) 0)))
#+END_SRC

#+RESULTS:
#+begin_example

(t 2 6)

(t 3 4)

(t 4 3)

(t 5 9)

(t 6 2)

(t 7 8)

(t 8 7)

(t 9 5)
#+end_example

8, or 4 depending on if you consider flipping the operands the same pair of numbers
**** 4. 
#+BEGIN_SRC emacs-lisp :results output 
(loops-and-preds [2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21] 
  (lambda (i j) (= (% (+ (* j i) 1) 23) 0)))

#+END_SRC

#+RESULTS:
#+begin_example

(t 2 11)

(t 3 15)

(t 4 17)

(t 5 9)

(t 6 19)

(t 7 13)

(t 8 20)

(t 9 5)

(t 10 16)

(t 11 2)

(t 12 21)

(t 13 7)

(t 14 18)

(t 15 3)

(t 16 10)

(t 17 4)

(t 18 14)

(t 19 6)

(t 20 8)

(t 21 12)
#+end_example

: 20

There are 20 pairs, or 10 if you don't count reversed operands. 
**** 5.  
#+BEGIN_SRC emacs-lisp :results output
(loops-and-preds [2 3 4 5 6 7] (lambda (i j) (= (% (- (* i j) 1) 9) 0)))
#+END_SRC

#+RESULTS:
: 
: (t 2 5)
: 
: (t 4 7)
: 
: (t 5 2)
: 
: (t 7 4)

: 4 or 2 if you don't count flipped operands

** DONE WRA
   CLOSED: [2018-01-30 Tue 22:12]
   :LOGBOOK:
   CLOCK: [2018-01-30 Tue 22:04]--[2018-01-30 Tue 22:12] =>  0:08
   :END:
There is an elegent proof that can be found that demonstrates that 1/2 + ... 1/2^n is a convergent series. I could explain it here, 
but I fear I would not do it justice, however, I will attempt to put it in my own words. You can find a complete proof here -> https://www.quora.com/How-does-1-2-+-1-4-+-1-8-+-1-16-+-%E2%80%A6-till-infinity-have-a-sum

We know that because we are dealing with fractions, an infinite sum of smaller and smaller pieces will eventually approach a limit of some number. 
We can for all intents and purposes call this limit the sum, as given an infinite amount of iterations, it will would reach it. This is why some infinite series
can have finite sums. I encourage you to read the full proof, as it can explain it much better than I can; I am not a mathematician yet \smiley.

Also, if you want to throw in some calculus, \sum 1/2^n as n goes from 0 to infinity is a geometric series. There is a simple test we can use to determine if a geometric series converges. 
The forumula to determine if it converges is 1/(1 - r), where r is the common ratio (in this case 1/2). if |r| < 1, then the series converges to 1/(1-r), if r \ge 1, then the series
diverges. 

r = 1/2, so it converges.  1/(1 - 1/2) = 2, so it converges to 2. 
** DONE TNL
   CLOSED: [2018-01-30 Tue 22:12]
   :LOGBOOK:
   CLOCK: [2018-01-30 Tue 22:12]--[2018-01-30 Tue 22:12] =>  0:00
   :END:
    The counterpart of \sum is \Pi or Pi (uppercase) The notation is the same
    as sigma, but the terms are multplied instead of added. 
** DONE WRD
   CLOSED: [2018-01-30 Tue 22:13]
   :PROPERTIES:
   :ORDERED:  t
   :END:
   :LOGBOOK:
   CLOCK: [2018-01-30 Tue 22:13]--[2018-01-30 Tue 22:13] =>  0:00
   :END:
#+BEGIN_SRC emacs-lisp
(require 'cl)

(loop for i from 0 to 10
   sum (loop for j from i to 5
      sum (* j 2 i)))


(loop for i from 0 to 10
   sum (loop for j from 0 to i
      sum (* i (+ 5 (- i j))))) 


#+END_SRC

#+RESULTS:
: 490

** DONE TNQ
   CLOSED: [2018-01-30 Tue 22:14]
   :LOGBOOK:
   CLOCK: [2018-01-30 Tue 22:13]--[2018-01-30 Tue 22:14] =>  0:01
   :END:

I found the measure-time macro on an elisp mailing list \smiley 
    #+BEGIN_SRC emacs-lisp
    (defmacro measure-time (&rest body)
  "Measure the time it takes to evaluate BODY."
  `(let ((time (current-time)))
     ,@body
     (message "%.06f" (float-time (time-since time)))))

(defun calculate-pi-very-slowly (max-iterations)
  (* 4 (loop for n from 0 to max-iterations
             sum (/ 1.0 (* (+ (* 2 n) 1) (expt -1 n))))))

;(measure-time (calculate-pi-very-slowly 5000000))
 (calculate-pi-very-slowly 5000000)

    #+END_SRC

    #+RESULTS:
    : 3.1415928535897395

Based on the approach that this method is using, and considering the fact that \pi is an irrational number, 
I'm not convinced that this will EVER give you pi. It would take an infinite amount of iterations. Just to get
to the point above took about a minute and 20 sec on a pretty powerful laptop, and it's still not even accurate 
past 10^-6 power. 

** DONE WRP
   CLOSED: [2018-01-30 Tue 22:16]
   :LOGBOOK:
   CLOCK: [2018-01-30 Tue 22:15]--[2018-01-30 Tue 22:16] =>  0:01
   :END:
   
**** ∃ x P(x)
     There exists in x such that x is older than 21
     OR
     There is at least one person in the world who is older than 21
**** ∀ x P(x)
     Every person the domain of all people is 21
     OR
     All people are older than 21
**** ∃ x ¬ P(x)
     There exists in x such that someone is NOT 21
     OR
     There is at least one person in the world who is not 21
**** ∀ x ¬ P(x)
     No person is 21
** DONE TOJ
   CLOSED: [2018-01-30 Tue 22:18]
   :LOGBOOK:
   CLOCK: [2018-01-30 Tue 22:16]--[2018-01-30 Tue 22:18] =>  0:02
   :END:
**** ∃ x S(x)
     There is at least one resident of Idaho who is student at BYU-Idaho
**** ∀ x S(x)
      All residents of Idaho are students at BYU-Idaho
**** ¬∃ x S(x)
      There are no residents of Idaho who are students at BYU-Idaho
**** ∃ x ¬ S(x)
      There is at least one resident of Idaho who is not a student at BYU-Idaho
**** ¬∀ x ¬ S(x)
     Some residents of Idaho are BYU-Idaho students
**** ∀ x ¬ S(x)
    No residents of Idaho are BYU-Idaho students
** DONE WRU
   CLOSED: [2018-01-30 Tue 22:20]
   :LOGBOOK:
   CLOCK: [2018-01-30 Tue 22:18]--[2018-01-30 Tue 22:20] =>  0:02
   :END:

**** ∀ x (F(x) → C(x))
      Every friend is cool
**** ∃ x (F(x) ∧ C(x))
      There are friends that are cool
**** ∀ x (F(x) ∧ C(x))
      In the reading, it says that this should be written as  ∀ x (F(x) → C(x))
      which means that every friend is cool
**** ∃ x (F(x) → C(x))
     This is also expressed incorrectly according to section DEV, it should be
     ∃ x (F(x) ∧ C(x)) which means that there are friends that are cool
** DONE TOL
   CLOSED: [2018-01-30 Tue 22:21]
   :LOGBOOK:
   CLOCK: [2018-01-30 Tue 22:20]--[2018-01-30 Tue 22:21] =>  0:01
   :END:
**** ∀ x (S(x) → R(x))
      All students are from Russia
**** ∃ x (R(x) → R(x))
     Should be written as  ∃ x (S(x) ∧ R(x))
     There are students who are from Russia
     See DEV
**** ∀ x (S(x) ∧ R(x))
     Should be written as ∀ x (S(x) → R(x)) See DEV
     and means All students are from Russia
**** ∃ x (S(x) ∧ R(x))
    There are students who are from Russia
** DONE WZO
   CLOSED: [2018-01-30 Tue 22:23]
   :LOGBOOK:
   CLOCK: [2018-01-30 Tue 22:21]--[2018-01-30 Tue 22:23] =>  0:02
   :END:

**** Everyone’s a critic.
     \forall x (S(x)) where S(x) = x is a critic and the domain is all people
**** No one is perfect.
     \forall x \not (S(x)) where S(x) = x is perfect and the domain is all people
**** At least one of your friends is perfect.
     \exists x (S(x)) where S(x) = x is perfect and the domain is friends
**** All of your friends are critics.
     \forall x (S(x)\rightarrow C(x)) where S(x) = x is your friend and C(x) = x is a critic and the domain is all people
**** Everyone is a critic or someone is your friend.
    \forall x (C(x)) \vee \exist x (S(x)) where C(x) = x is a critic and S(x) = x is your friend and the domain is all people
**** No one is a critic and everyone is your friend.
     \not \exists x (C(x)) \wedge \forall x (S(x)) where C(x) = x is a critic and S(x) = x is your fr
** DONE TOU
   CLOSED: [2018-01-30 Tue 22:27]
   :LOGBOOK:
   CLOCK: [2018-01-30 Tue 22:23]--[2018-01-30 Tue 22:27] =>  0:04
   :END:
**** All horses have hooves
     \forall x (H(x) \rarr h(x)) where H(x) = x is a horse and h(x) = x has hooves
     \exists X (H(x) V \not h(x))
     
     There exists a horse that does not have hooves
**** No horses can fly
     \forall x (H(x) \rarr f(x)) where H(x) = x is a horse and f(x) = x cannot fly
     \exists x (H(x) V \not f(x)) 
     There exist some horses who can fly. 
**** Every bat is blind
     \forall x (B(x) \rarr b(x)) where B(x) = x is a bat, and b(x) = x is blind
     \exists x (B(x) V \not b(x))
     There exists a bat which is not blind
**** No bear can dance
     \forall x (B(x) \rarr d(x)) where B(x) = x is a bear and d(x) = x can't dance
     \exists x (B(x) V \not d(x)) 
      There exists a bear which can dance. 
**** There is at least one penguin that can swim and catch fish
    \exists x (S(x) \wedge C(x))  S(x) = x can swim and C(x) = x can catch fish. The domain of x is all penguins
    \forall x (\not S(x) V \not C(x)) 
    There are no pengiuns that can swim or catch fish
** DONE WYH
   CLOSED: [2018-01-30 Tue 22:37]
   :LOGBOOK:
   CLOCK: [2018-01-30 Tue 22:27]--[2018-01-30 Tue 22:37] =>  0:10
   :END:
**** 1. 
     \exists x (C(x) \wedge a(x)) where x is a song C(x) = x can be sung a(x) = there is a soul alive
**** 2.
     \forall x (m(x)) where x the set of all errors m(x) = displays an error
**** 3.
     \exists x (P(x) \wedge V(x)) where x is the set of scanned programs. P(x) = x is a program, V(x) = x has a virus
** DONE TLI
   CLOSED: [2018-01-30 Tue 22:39]
   :LOGBOOK:
   CLOCK: [2018-01-30 Tue 22:37]--[2018-01-30 Tue 22:39] =>  0:02
   :END:
   1. False. There are many integers greater than 1
   2. False. (-1)^2 = 1
   3. True.
   4. False
** DONE WPI
   CLOSED: [2018-01-30 Tue 22:40]
   :LOGBOOK:
   CLOCK: [2018-01-30 Tue 22:39]--[2018-01-30 Tue 22:40] =>  0:01
   :END:
   1. True
   2. False
   3. True
   4. True
** DONE TSD
   CLOSED: [2018-01-30 Tue 22:43]
   :LOGBOOK:
   CLOCK: [2018-01-30 Tue 22:40]--[2018-01-30 Tue 22:43] =>  0:03
   :END:
1. \exists x (E(x) \wedge \not L(x) \wedge \not R(x))
2. \exist x (L(x) \wedge \not R(x))
3. \exists x (E(x) \wedge \not R(x))
4. \exists x (E(x) \wedge L(x))
** DONE WTM
   CLOSED: [2018-01-30 Tue 22:44]
   :LOGBOOK:
   CLOCK: [2018-01-30 Tue 22:43]--[2018-01-30 Tue 22:44] =>  0:01
   :END:
   1. \not \exists x (L(x) \wedge D(x))
   2. \forall x (S(x) \rarr D(x))
   3. \forall x (F(x) \rarr L(x))
   4. \not \exists (F(x)\wedge S(x))
   5. Yes it does.
** DONE TTV
   CLOSED: [2018-01-30 Tue 22:47]
   :LOGBOOK:
   CLOCK: [2018-01-30 Tue 22:44]--[2018-01-30 Tue 22:47] =>  0:03
   :END:
   1. True cube root of -9 is approx -2.08
   2. True
   3. True
   4. False 2 * (-2) = -4; -4 \gt -2 is false
** DONE WUZ
   CLOSED: [2018-01-30 Tue 22:47]
    :LOGBOOK:
    CLOCK: [2017-10-06 Fri 16:20]--[2017-10-06 Fri 17:53] =>  1:33
    :END:

#+BEGIN_SRC emacs-lisp :results raw
(defun is-true-even (x)
   (= 0 (% x 2)))

(defun is-false-even (x)
   (not (is-true-even x)))

(defun is-true-odd (x)
   (not (is-true-even x)))

(defun is-false-odd (x)
   (is-true-even x))

(defun for-all (set func)
   (loop for i in set
      always (funcall func i)))

(defun for-some (set func)
   (loop for i in set
      thereis (funcall func i)))

(for-all '(3 1 7 8) 'is-true-even)

#+END_SRC

#+RESULTS:
nil
t
t
nil

** DONE WZM
   CLOSED: [2018-01-30 Tue 22:49]
**** Injective
     \forall a,b \in X
**** Surjective
     \forall y \in Y, \exists x \in X 
** DONE TUK 
   CLOSED: [2018-01-30 Tue 22:50]
   :LOGBOOK:
   CLOCK: [2018-01-30 Tue 22:49]--[2018-01-30 Tue 22:50] =>  0:01
   :END:
**** 1. ∃ x ∀ y (x > y)
     There exists an X that is greater than all y. False?
**** ∃ x ∃ y (((x ≥ 0) ∧ (y ≥ 0)) → (xy ≥ 0))
     There exists an x and a y that if x is greater than or equal to 0  and y is greater than or equal to zero, then x multiplied by y is greater than zero. This is true.
****  ∃ x ∀ y ∃ z (x = y + z)
     There exists an x and z for all y that x equals y plus z.
** DONE WVQ
   CLOSED: [2018-01-31 Wed 15:32]
   :LOGBOOK:
   CLOCK: [2018-01-31 Wed 15:29]--[2018-01-31 Wed 15:32] =>  0:03
   :END:
Let Q(x, y) be the statement “x asks y a question,” where the domain for both x and y consists of all students in a class. Express each quantification in an English sentence.
**** 1. ∀ x ∃ y Q(x, y)
    All students ask at least one other student a question in a class 
**** 2. ∀ x ∀ y Q(x, y)
     All students ask all other students a question in a class
**** 3. ∃ x ∃ y Q(x, y)
     Some students ask some other students a question in class
**** 4. ∃ x ∀ y Q(x, y)
     Some students ask all other students a question in class
**** 5. ∀ y ∃ x Q(x, y)
     All students are asked a question by some students in a class
**** 6. ∃ y ∃ x Q(x, y)
     Some students are asked a question by some students in the class
** DONE TUQ
   CLOSED: [2018-01-31 Wed 19:10]
   :LOGBOOK:
   CLOCK: [2018-01-31 Wed 19:08]--[2018-01-31 Wed 19:10] =>  0:02
   CLOCK: [2018-01-31 Wed 15:32]--[2018-01-31 Wed 15:32] =>  0:00
   :END:
**** 1.
     \not \forall x \forall y Q(S(x),T(y))
**** 2. 
     \exists x \exists y Q(S(x), T(y))
**** 3. 
     \forall x \exists y (Q(S(x), T(y))) \wedge (Q(S(x), A(x)))
**** 4. 
     \exists x \exists y Q((S(x) \wedge (x \ge 2)), T(y))
** DONE WVU 
   CLOSED: [2018-01-31 Wed 19:11]
   :LOGBOOK:
   CLOCK: [2018-01-31 Wed 19:10]--[2018-01-31 Wed 19:11] =>  0:01
   :END:
   x is a teacher and y is a class
**** 1. 
     \not\exists x \forall y T(x, y)
**** 2.
     \forall x \forall y T(x, y)
**** 3.
    \exists x \forall y (T(x, y) \wedge (x \ge 2) 
**** 4.
    \not \exists x \forall y T(x, y)
** DONE TUW
   CLOSED: [2018-01-31 Wed 19:12]
   :LOGBOOK:
   CLOCK: [2018-01-31 Wed 19:11]--[2018-01-31 Wed 19:12] =>  0:01
   :END:
   1. Every CS Major needs to take discrete mathematics
      T(x,y) = x must take y
      C(x) = x is a computer science major
      \forall x (C(x) \rarr T(x, Discrete Math))
   2. Every student in the class owns a laptop 
      domain is student in the class
      O(x, y) x owns y. 
      \forall x O(x, laptop)
   3. There is a student in the class that has taken data structures.
      D(x,y) = x has taken y
      \exists x D(x, Data Structures)
   4. No student has been in every building at the University
      The domain is all students and buildings at the University.
      F(x, y) x has been in y S(x) x is a student B(x) x is a building
      \not \forall x \forall y F(S(x), B(x))
   5. Exactly one student has been in every room in the STC
      The domain is all students and buildings
      F(x,y) x has been in y. S(x) x is a student B(x) x is the STC
      \exists! x F(S(x), B(x))
   6. \forall x \exists y \forall z F(x,y,z) x has been in room y in building z 
** DONE WWD
   CLOSED: [2018-01-31 Wed 19:22]
   :LOGBOOK:
   CLOCK: [2018-01-31 Wed 19:12]--[2018-01-31 Wed 19:22] =>  0:10
   :END:
   1. \not \forall x (C(x) \rarr T(x, Discrete Math)) => \exists x(C(x) \land \not T(x, Discrete Math))

   2. \not \forall x O(x, laptop) =>  \exists x \not O(x, laptop)

   3. \not \exists x D(x, Data Structures) => \forall x \not D(x, Data Structures)

   4. \not \forall x \forall y F(S(x), B(x)) => \exists x \exist y \not F(S(x), B(x))

   5. \not \exist!x F(S(x), B(x)) => \forall x \not F(S(x), B(x))

   6. \not \forall x \exist y \forall Z F(x,y,z) => \exists x \forall y \exist z \not F(x, y, z)
** DONE TVL
   CLOSED: [2018-01-31 Wed 19:22]
   :LOGBOOK:
   CLOCK: [2018-01-31 Wed 19:21]--[2018-01-31 Wed 19:22] =>  0:01
   :END:
   1. Jackon Andrews dropped out of Discrete Mathematics.
   2. There is a student who has dropped out of all classes
   3. All students have dropped out of a class
** DONE WWR
   CLOSED: [2018-01-31 Wed 19:24]
   :LOGBOOK:
   CLOCK: [2018-01-31 Wed 19:22]--[2018-01-31 Wed 19:24] =>  0:02
   :END:
   1. \forall x \exists y ( (x + y)/2 \le x \le y) )
   2. \forall x \forall (x * -y < 0)
   3. \not \exists x F(x) where F(x) = x can be divided by 0
   4. \forall x (F(x) > 0) where F(x) = x is a positive number
** DONE TWN
   CLOSED: [2018-01-31 Wed 19:24]
   :LOGBOOK:
   CLOCK: [2018-01-31 Wed 19:23]--[2018-01-31 Wed 19:24] =>  0:01
   :END:
   \not \exist x P(x) \wedge F(x): P(x) x is a prime number and F(x) = x has 3 factors
** DONE WWS 
   CLOSED: [2018-01-31 Wed 19:25]
   :LOGBOOK:
   CLOCK: [2018-01-31 Wed 19:24]--[2018-01-31 Wed 19:25] =>  0:01
   :END:
   1. True
   2. True
   3. True
   4. True
** DONE TXG
   CLOSED: [2018-01-31 Wed 19:26]
   :LOGBOOK:
   CLOCK: [2018-01-31 Wed 19:26]--[2018-01-31 Wed 19:26] =>  0:00
   :END:
   1. True
   2. False
   3. True
   4. True
   5. True
   6. False
   7. False
   8. True
** DONE WZG
   CLOSED: [2018-01-31 Wed 19:28]
   :LOGBOOK:
   CLOCK: [2018-01-31 Wed 19:26]--[2018-01-31 Wed 19:28] =>  0:02
   :END:
   1. All real numbers
      true
   2. The natural numbers
      false if zero is not included
   3. All negative integers
      true
   4. rational numbers
      true
** DONE TKH
   CLOSED: [2018-01-31 Wed 19:30]
   :LOGBOOK:
   CLOCK: [2018-01-31 Wed 19:29]--[2018-01-31 Wed 19:30] =>  0:01
   :END:
#+BEGIN_SRC emacs-lisp :results raw
(defun is-true-even (x)
   (= 0 (% x 2)))

(defun is-false-even (x)
   (not (is-true-even x)))

(defun is-true-odd (x)
   (not (is-true-even x)))

(defun is-false-odd (x)
   (is-true-even x))

(defun for-all (set func)
   (loop for i in set
      always (funcall func i)))

(defun for-some (set func)
   (loop for i in set
      thereis (funcall func i)))

(defun for-all-for-all (x y pred)
   (loop for i in x
     always (loop for j in y
         always (funcall pred i j))))

(defun for-some-for-some (x y pred)
    (loop for i in x
       thereis (loop for j in y
          thereis (funcall pred i j))))

(defun for-all-for-some (x y pred)
    (loop for i in x
        always (loop for j in y
           thereis (funcall pred i j))))

(defun for-some-for-all (x y pred)
   (loop for i in x
      thereis (loop for j in y
         always (funcall pred i j))))

(defun x-greater-y (x y)
(> x y))

;;(for-all '(4 2 6 8) 'is-true-even)
;;(for-all-for-all '(9 9 9 9 9 9) '(6 2 3 4 5 6 7) 'x-greater-y)
;;(for-some-for-some '(1 2 3 4) '(5 1 7 8) 'x-greater-y)

#+END_SRC   

#+RESULTS:
t
nil
nil
t
nil
x-greater-y
t
nil
nil
nil
t

** DONE WUE
   CLOSED: [2018-01-31 Wed 19:31]
   :LOGBOOK:
   CLOCK: [2018-01-31 Wed 19:30]--[2018-01-31 Wed 19:31] =>  0:01
   :END:
   ∀x∃yP(x,y)

   Stated in English this would say that for all blessings x there exists a law y.
   This is almost identical to how the scripture is worded. 

   
* DONE Day 1
  CLOSED: [2018-01-29 Mon 17:38]
  :LOGBOOK:
  CLOCK: [2018-01-29 Mon 17:30]--[2018-01-29 Mon 17:38] =>  0:08
  :END:

** Closures

Global Vars
#+BEGIN_SRC emacs-lisp :lexical t :lexical-binding t
  (setq x 2)
  (defvar ticker nil)
#+END_SRC

#+RESULTS:
: ticker
  

#+BEGIN_SRC emacs-lisp :lexical-binding t :lexical t
(let ((x 1))
   (setq ticker (lambda () (setq x (+ 1 x)))))
#+END_SRC

#+RESULTS:
| closure | ((x . 1) t) | nil | (setq x (+ 1 x)) |

#+BEGIN_SRC emacs-lisp :lexical-binding t :lexical t
  (funcall ticker)
#+END_SRC

#+RESULTS:
: 5

** Euclidean GCD Algorithmn
   
#+BEGIN_SRC emacs-lisp :results raw
  (gcd 97 11)
#+END_SRC

#+RESULTS:
1
1

#+BEGIN_SRC emacs-lisp :results silent
  (defun step (a b)
    (let ((q (/ a b))
         (r (% a b)))
      (list a "=" b q "+" r)))
#+END_SRC


#+BEGIN_SRC emacs-lisp
  (step 97 11)
#+END_SRC

#+RESULTS:
| 97 | = | 11 | 8 | + | 9 |




#+BEGIN_SRC emacs-lisp
  (append (list '(a = b q + r))
     (let* ((a 97) (b 11) (c a))
       (loop while (> b 0) 
          collect (step a b)
          do (setq a (nth 2 (step a b)) b (nth 5 (step c b)) c a))))
#+END_SRC

|  a | = |  b | q   | + | r |
| 97 | = | 11 | (8) | + | 9 |
| 11 | = |  9 | (1) | + | 2 |
|  9 | = |  2 | (4) | + | 1 |
|  2 | = |  1 | (2) | + | 0 |

* DONE Day 2
  CLOSED: [2018-01-30 Tue 22:16]

#+BEGIN_SRC emacs-lisp :results silent
  (defun one-over (frac)
     (cons (denominator frac) (numerator frac)))

  (defun numerator (frac)
   (car frac))

   (defun denominator (frac)
     (cdr frac))
#+END_SRC


#+BEGIN_SRC emacs-lisp
  (one-over (cons 3 5))
#+END_SRC

#+RESULTS:
: (5 . 3)

* DONE Day 3
  CLOSED: [2018-01-31 Wed 21:04]
  :LOGBOOK:
  CLOCK: [2018-01-31 Wed 20:45]--[2018-01-31 Wed 21:04] =>  0:19
  CLOCK: [2018-01-31 Wed 19:07]--[2018-01-31 Wed 19:07] =>  0:00
  CLOCK: [2018-01-31 Wed 15:21]--[2018-01-31 Wed 16:38] =>  1:17
  :END:

** What do Continued Fractions and the Euclidean GCD have in common?

   97 = 11 * 8 + 9

#+BEGIN_SRC emacs-lisp :results silent
(defun flipover (x)
   (and (consp x) (cons (cdr x) (car x))))

(defun oneover (x)
   (if (numberp x) 
      (/ 1.0 x)
      (flipover x)))

(defun plus (a c)
 (if (and (numberp a) (numberp c))
   (+ a c)
 (destructuring-bind (n . d) c
    (cons (+ n (* a d)) d))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (oneover '(9 . 11))
#+END_SRC

#+RESULTS:
: (11 . 9)
  
** Generate

#+BEGIN_SRC emacs-lisp :results silent
  (defun gen-frac-decomp (a)
    (unless (zerop (cdr a))
    (let* ((result (step (car a) (cdr a)))
          (a (first result))
          (b (third result))
          (q (fourth result))
          (r (sixth result)))
      (cons q (gen-frac-decomp (cons b r))))))
#+END_SRC


#+BEGIN_SRC emacs-lisp :results raw
  (gen-frac-decomp '(97 . 11))
#+END_SRC

#+RESULTS:
(8 1 4 2)

#+BEGIN_SRC emacs-lisp :results silent
  (defun rev-frac-decomp (q)
    (if (not (null q))
        (list 'oneover (list 'plus (car q) (rev-frac-decomp (cdr q))))
       (list 'oneover '(cons 1 0))))
  

  (defun rev-frac-first-line (q)
  (list 'plus (car q) (rev-frac-decomp (cdr q))))
#+END_SRC


#+BEGIN_SRC emacs-lisp :results raw
 (eval (rev-frac-first-line  (gen-frac-decomp (cons 97 11))))
#+END_SRC

#+RESULTS:
(97 . 11)
(97 . 11)
(97 . 11)
(plus 8 (oneover (plus 1 (oneover (plus 4 (oneover (plus 2 (oneover (cons 1 0)))))))))

#+BEGIN_SRC emacs-lisp
  (gen-frac-decomp (cons 97 11))
#+END_SRC

#+RESULTS:
| 8 | 1 | 4 | 2 |
* DONE Day 4
  CLOSED: [2018-02-01 Thu 15:42]
  :LOGBOOK:
  CLOCK: [2018-02-01 Thu 15:16]--[2018-02-01 Thu 15:42] =>  0:26
  :END:
