#+TITLE: Workbook for DM1
#+AUTHOR: Bryan Muller
#+EMAIL: mul13001@byui.edu
#+DATE: September 17
#+STARTUP donotshoweverything entitiespretty

* Track Pick
I will strive for track A. I believe that with diligent work and 
effort, I can master the topics. I will most likely attempt most 
of the coding challenges first in JavaScript, and then, time permitting, 
transfer them to LISP. I want to make it through all the exercises first,
and as the semester goes on, I'm hoping that the LISP will become easier, and 
I will begin to be able to solve all the problems just in LISP.  

#+BEGIN_SRC emacs-lisp
(setq inumber 457572324)
(list inumber)
#+END_SRC

#+RESULTS:
| 457572324 |

* Week 0

** CRC
   
*** What is a tetragramamalgam?
    Well if you break down the word into two parts, you get tetragram and amalgam.
    A tetragram is a 4 letter word, which makes sense if we are discussing EGGS (4 letters).
    An amalgam is a combination of things. So I would say that a tetragramamalgam is a set of 
    all possible combinations of the letters in the word EGGS.

*** EGGS
    let E = 1, G = 2 G = 3 S = 4   

    (1234 1243 1432 2134 2314 2341 2413 2431 4123 4213 4231)
    (EGGS EGSG ESGG GEGS GGES GGSE GSEG GSGE SEGG SGEG SGGE)

    
*** Sand dune picture 
    I think this represents discrete math in a couple ways. First of all, the desert is made up 
    up of discrete particles of sand. Also, discrete math is a vast field. Each grain of sand could
    represent a facet of the field. 
   
    
** DGZ 

   THE TIME HAS COME THE WALRUS SAID TO
   TALK OF MANY THINGS OF SHOES AND SHIPS
   AND SEALING WAX OF CABBAGES AND KINGS
   AND WHY THE SEA IS BOILING HOT AND WHETHER PIGS HAVE WINGS
 
** CHJ

   This was the smallest ration I could find assuming y is a vowel:
   
   strengths v/c 1/8

 
** DOK

   
   1 * 2 * 3 = 6 

   2 * 3 * 5 = 30

   3 * 4 * 7 = 84

   4 * 5 * 9 = 260

   5 * 6 * 11 = 330

   6 * 7 * 13 = 546

   7 * 8 * 15 = 840

   8 * 9 * 17 = 1224

   9 * 10 * 19 = 1710

   10 * 11 * 21 = 2310


   Patterns: 
   
*** The results are all even numbers

*** The results are all divisible by 3

*** The results are all divisible by 6

*** The (2x) + 1 terms are the ascending odd numbers

*** The last digits of the product seem to be following a pattern of 6040060400... 

** UJF 
   When approaching this problem, I had the same idea as what was later suggested in the hint.
   Because we know the circle is inscribed within an equilateral triangle, we can use basic trigonmetry 
   to find the length of one of its sides. We can continue this pattern by using trigonmetry to then find the radius of 
   the circle surrounding the triangle, and so forth. This approach was also later hinted at by Brother Neff. This runs into 
   an issue of course, because as we approach the outer edge, we are unable to know how many or what shapes there are. 
   That being said, there is a pattern to the trig. After each iteration, the ratio that is used to represent the angle is 
   modified by a factor of one in the denominator. What begins with pi/3 moves to pi/4 -> pi/5 -> pi/6 -> pi/7 -> pi/8 etc.
   Say there are n shapes within this structure. We could construct a function/limit where X initial =3 (and x is the denominator of the radian) 
   as x approaches n, that would allow us to solve this problem. Sadly my calculus skills were too rusty to actually construct the limit, but I believe that 
   it is possible. For this reason, I would say that this is a continuous math problem. Perhaps there is a better 'discrete' method of approaching this problem,
   but this is the method I thought of. 
   

UPDATE: Here is a Javascript solution. The limit of the radius as it approaches the num of shapes is 8.7 
#+BEGIN_SRC javascript
const getSide = (x, it) => {
  return x / Math.cos(Math.PI/it);
}

const getLimit = (sides) => {
  let rad = 1.0;
  for(let i = 3; i < sides; i++) {
    rad = getSide(rad, i);
  }
  console.log(rad)
}

getLimit(10000000)
#+END_SRC

* Week 1 ABC

** USV
 #+BEGIN_SRC emacs-lisp
(rot13 "Or pyrire jvgu ahzoref. Svaq n jnl gb vafreg vagb gurfr gra yvarf gur sbhe fgnaqneq zngu bcrengbef 
(+, -, \gvzrf, \qvi), be ! (snpgbevny), be \enqvp (fdhner ebbg), naq cneragurfrf sbe tebhcvat, gb znxr gra
 qvssrerag rkcerffvbaf gung rnpu rinyhngr gb 6. Sbe rknzcyr: \enqvp4 + \enqvp4 + \enqvp4 = 6.")
 
 #+END_SRC

 #+RESULTS:
 : Be clever with numbers. Find a way to insert into these ten lines the four standard math operators 
 : (+, -, times, div), or ! (factorial), or adic (square root), and parentheses for grouping, to make ten
 :  different expressions that each evaluate to 6. For example: adic4 + adic4 + adic4 = 6.

    ( 0! + 0! + 0! )!                     = 6 
    ( 1 + 1 + 1 )!                        = 6 
    ( 2 + 2 + 2 )                         = 6 
    ( 3 * 3 - 3 )                         = 6 
    ( ^[adic(4*4)]! / 4 )                 = 6 
    ( 5 / 5 + 5 )                         = 6 
    ( 6 / 6 * 6 )                         = 6 
    ( 7 - 7 / 7 )                         = 6 
    ( ^[adic(8+8)]! / 8)!                 = 6 
    (^[adic(9)]* ^[adic(9)] - ^[adic(9)]) = 6 

** OQP
   I worked through the entire primer notebook.
   #+BEGIN_SRC emacs-lisp
   (+ 1 2 3 4)
   #+END_SRC

   #+RESULTS:
   : 10

** ABF - Which proposition is false?
   I would say the proposition on numbers. To quote, "The square of a number is more than double that number."
   Assuming that this is a statement for every case, it is clearly false. 2 * 2 = 4, 2^2 = 4 therefore 2*2 = 2^2, so
   that satement is false for that case, rendering it untrue if applied to all numbers. 

** UCA
   It is my understanding of the text that propositions can be true OR false.
*** Propositions
    Rain falls down. 
    Chickens are birds
    Fish have fur
*** Non-Propositions
    Fetch me some water
    What is your middle name?
    How many colors are there?
** ODS
*** Guide:
    P = proposition
    NP = non-proposition
***   
      1. P true
      2. P false
      3. P false
      4. NP n/a
      5. P Depending on the values of each variable, it could be true or false
      6. NP n/a
      7. P given that x = 3, than it is true, otherwise it is false
      8. NP n/a
** UGX
   'v' \in C 

** OGR   
   1. simple proposition
   2. compound proposition
   3. compound proposition
   4. compound proposition

   So only the first item is a simple proposition.
   
** ABG
   #+BEGIN_SRC emacs-lisp
 (defun xor (p q)
   (if p (not q) q))
 (setq true t false nil)
 (list (xor false false)
       (xor false true)
       (xor true false)
       (xor true true))
   #+END_SRC

   #+RESULTS:
   | nil | t | t | nil |

** UWM
   1. Two plus two does not equal four
   2. Two plus 1 is greater than four
   3. Toronto is not the capital of Germany
   4. A total eclipse happens frequently
   5. Special measures must not be taken to deal with the current situation
   

** OPZ 
   1. I did not study
   2. I studied or I got an F on the test
   3. I studied and I got an F on the test
   4. I did not study and I did not get an F on the test
   5. I did not study or I got an F on the test
   6. I did not study and I did not get an F on the test
   
** UOX  
   Check special forms
   1. =when=
   2. =unless=
   3. =cond=
   4. =not=
   5. =and=
   6. =or=

      According the the gnu emacs manual, "A special form is a primitive function specially
      marked so that its arguments are not all evaluated. For example, the if function executes 
      only a certain part of its code block depending on which of the conditions is evaluated. 
   
** OTX
   1. xor
   2. or
   3. or
   4. or
   5. xor
   6. xor
   
** UOT 
  
Truth table for equation 2:

| p | q | r | p and q (A) | not r (B) | (A) or (B) |
|---+---+---+-------------+-----------+------------|
| 0 | 0 | 0 |           0 |         1 |          1 |
| 0 | 0 | 1 |           0 |         0 |          0 |
| 0 | 1 | 0 |           0 |         1 |          1 |
| 0 | 1 | 1 |           0 |         0 |          0 |
| 1 | 0 | 0 |           0 |         1 |          1 |
| 1 | 0 | 1 |           0 |         0 |          0 |
| 1 | 1 | 0 |           1 |         1 |          1 |
| 1 | 1 | 1 |           1 |         0 |          1 |

Comparison between the 2:
| EQ1 | EQ2 |
|-----+-----|
|   0 |   1 |
|   0 |   0 |
|   0 |   1 |
|   0 |   0 |
|   1 |   1 |
|   0 |   0 |
|   1 |   1 |
|   1 | 1   |

** ABK
#+BEGIN_SRC emacs-lisp
(setq A [1 2 3 4 5 6 7 8]
      B [5 6 7 8 9 10 11 12]
      A-intersect-B[5 6 7 8])
#+END_SRC

#+RESULTS:
: [5 6 7 8]

#+BEGIN_SRC emacs-lisp
(setq A [1 2 3 4 5 6 7 8]
      B [5 6 7 8 9 10 11 12]
      A-union-B [1  2 3 4 5 6 7 8 9 10 11 12])
#+END_SRC

#+RESULTS:
: [1 2 3 4 5 6 7 8 9 10 11 12]


** OIM  
   The first column represents the decimal value given in binary by the last three columns. 
   If A,B,C could be represented as being true (1), and their compliments as being false (0), the middle column
   reflects the binary number in its set logic. 
   
** UIN
   #+BEGIN_SRC emacs-lisp
(require 'cl)
(set-difference '(q w e r t y u i o p a s d f g h j k l z x c v b n m) '(a e i o u h k l m n p w))
   
   #+END_SRC

   #+RESULTS:
   | q | r | t | y | s | d | f | g | j | z | x | c | v | b |


** Email Puzzle 2 - the 5 hat problem
   
   The answer is 3: She has a white hat anc can prove it. 

   Let's call student one i, two, j, three k respectively. 

   We know immediately that j and k cannot both be wearing a red hat, because i would open his eyes,
   see two red hats, and know that he could not be wearing a red hat because there were only two in the box. 
   In otherwords, we know that (j AND k) = FALSE

   We also know that i and k are both not wearing a red hat for the same reason, so (i AND k) = FALSE
   When j hears that i does not know the color, he can deduce the following. Either he (j) and k are both wearing white hats, 
   or one of them is wearing a red hat. In otherwords ((NOT j AND NOT k) OR (j OR k)). 
   If j opens his eyes and sees that k has a red hat, then  he knows that he must be wearing a white, 
   because they both cannot be wearing red. This appears not to be the case as he says he is uncertain, which means he saw a white
   hat on k. This means that he (j) could be wearing either a red or a white hat (see above). Because
   he is unsure, k can deduce that she must be wearing a white hat. 


** OJL
   
   | A   | 4 ∪ 5 ∪ 7 ∪ 6	 | (p∧¬q∧¬r)∨(p∧¬q∧r)∨(p∧q∧r)∨(p∧q∧¬r) | correct |
   | B	 | 2 ∪ 3 ∪ 7 ∪ 6	 | (¬p∧q∧¬r)∨(¬p∧q∧r)∨(p∧q∧r)∨(p∧q∧¬r) | correct |
   | C	 | 1 ∪ 3 ∪ 5 ∪ 7	 | (¬p∧¬q∧r)∨(¬p∧q∧r)∨(p∧¬q∧r)∨(p∧q∧r) | correct |
** UCG

*** 1. A or B = C
    C = [verve vim vigor butter vinegar pepper]

*** 2. A and B = D
    D = [vigor]

*** 3. subset of C that start with 'v'
    [verve vim vigor vinegar]

*** 4. subset of C that end with 'r'
    [vigor butter vinegar pepper]
*** 5. subset of C that start with 'v' and end with 'r'
    [vigor vinegar]
*** 6. subset of D that have six letters
    [ ] -> empty
** OIO
   #+BEGIN_SRC emacs-lisp
(setq A [ s i z e]
      a (length A)
      B [b i g g e r i n s i z e]
      b (length B)
      A-is-a-subset-of-B (subsetp (append A nil) (append B nil))
      a-is-less-than-or-equal-to-b (<= a b))
   #+END_SRC

   #+RESULTS:
   : t

#+BEGIN_SRC emacs-lisp :results silent
  
#+END_SRC 
** UIJ
   The logical operator -> represents 'if... then', in other words, if the left side is true,
   then the right side is also true. If A is a subset of B, that means that anything in A(3) 
   is inside of B(2) (which is also in set U(1)). This means, that if a point is inside A,
   than it is also inside B (and U). This can be expressed with the \rightarrow symbol: A \rightarrow B (\rightarrow U). 
** OQT
*** 1. If I study I get an A on the test
*** 2. I did not study or I did not get an A on the test
*** 3. If I do not study, then I study or get an A on the test
*** 4. If I do not study, then I do not get an A on the test
** UTQ
   1. p ^ q
   2. \not p ^ q
   3. p ^ \not q
   4. (\not p ^ \not q) v (p ^ q)
** OYU
   1. p implies q
   2. p so q
   3. p therefore q
   4. every time p, q
** UOH
q->p
q->p
p<->q
** OZD
   1. if true than false : false
   2. if true than false : false
   3. if false than true : true
   4. if true than true : true
** UZM
   1. true
   2. false
   3. false
   4. true
** OOY
   1. If you want to win, then you must sign up
   2. If I go outside, then I get cold
   3. If you are an A student, then you will get a scholarship
   4. If you leave now, then you will get there on time
   5. If I act now, then I get half off

** UFZ
   Given p->q
   Converse q->p
   Inverse \not p -> \not q
   Contrapositive \not q -> \not p

** OKJ
*** 1. If it rains today, we won't go to the park   
    it rains = p we won't go to the park = 1

    converse: If we don't go to the park, it will rain
    inverse: If it does not rain today, we will go to the park
    contrapositive: We will go to the park if it does not rain.
*** 2. If you do your homework, I’ll give you a pat on the back.

    you do your homework = p I give you a pat on the back = q

    converse: If I give you a pat on the back, then you will do your homework.
    inverse: If you do not do your homework, I will not give you a pat on the back.
    contrapostive: If I do not give you a pat on the back, you will not do your homework
*** 3. Whenever I babysit, I get sick
    I babysit = p I get sick = q

    converse: If I get sick, then I babysit
    inverse: If I do not babysit, then I do not get sick
    contrapositive: if I do not get sick, then I do not babysit
*** 4. Every time there is a quiz, I go to class
    There is a quiz = p I go to class = q

    converse: Every time I go to class, there is a quiz
    inverse: If there is not a quiz, then I do not go to class
    contrapositive: If I do not go to class, then there is no quiz
*** 5. I wake up late when I stay up past my bedtime
    I wake up late = p I stay up past my bedtime = q

    converse: When I stay up past my bedtime, I wake up late.
    inverse: When I don't wake up late, I don't stay up past my bedtime
    contrapositive: When I don't stay up past my bedtime, I don't wake up late
** UVH
*** 1. p -> q
    
    | p | q | p->q |
    | 0 | 0 |    1 |
    | 0 | 1 |    1 |
    | 1 | 0 |    0 |
    | 1 | 1 |    1 |


*** 2. p \oplus q
    | p | q | p \oplus q |
    | 0 | 0 |     0 |
    | 0 | 1 |     1 |
    | 1 | 0 |     1 |
    | 1 | 1 |     0 |

*** 3. p → q  
    | p | q | p->q |
    | 0 | 0 |    1 |
    | 0 | 1 |    1 |
    | 1 | 0 |    0 |
    | 1 | 1 |    1 |

    
*** 4. ¬p→q
    | p | \not p | q | ¬p→q |
    | 0 |   1 | 0 |    0 |
    | 0 |   1 | 1 |    1 |
    | 1 |   0 | 0 |    1 |
    | 1 |   0 | 1 |    1 |

*** 5. p∧¬q   
    | p | q | \not q | ^ |
    | 0 | 0 |   1 | 1 |
    | 0 | 1 |   0 | 0 |
    | 1 | 0 |   1 | 1 |
    | 1 | 1 |   0 | 1 |

** OJM 

*** 1. p→(¬p)
    | p | \not p | p→(¬p) |
    | 0 |   1 |      1 |
    | 1 |   0 |      0 |

*** 2. p↔q

    | p | q | p↔q |
    | 0 | 0 |   1 |
    | 0 | 1 |   0 |
    | 1 | 0 |   0 |
    | 1 | 1 |   1 |

*** 3. p↔(¬p)
    | p | \not p | p↔(¬p) |
    | 0 |   1 |      0 |
    | 1 |   0 |      0 |

*** 4. p∧p

    | p | p∧p |
    | 0 |   0 |
    | 1 |   1 |

*** 5. p∨p

    | p | p∨p |
    | 0 |   0 |
    | 1 |   1 |

    
** ULQ

   | p | q | r | s | p->q | q->r | (p->q)->(q->r) | (r->s) | (p->q)->(q->r)->(r->s) |
   | 0 | 0 | 0 | 0 |    1 |    1 |              1 |      1 |                      1 |
   | 0 | 0 | 0 | 1 |    1 |    1 |              1 |      1 |                      1 |
   | 0 | 0 | 1 | 0 |    1 |    1 |              1 |      0 |                      0 |
   | 0 | 0 | 1 | 1 |    1 |    1 |              1 |      1 |                      1 |
   | 0 | 1 | 0 | 0 |    1 |    0 |              0 |      1 |                      1 |
   | 0 | 1 | 0 | 1 |    1 |    0 |              0 |      1 |                      1 |
   | 0 | 1 | 1 | 0 |    1 |    1 |              1 |      0 |                      0 |
   | 0 | 1 | 1 | 1 |    1 |    1 |              1 |      1 |                      1 |
   | 1 | 0 | 0 | 0 |    0 |    1 |              1 |      1 |                      1 |
   | 1 | 0 | 0 | 1 |    0 |    1 |              1 |      1 |                      1 |
   | 1 | 0 | 1 | 0 |    0 |    1 |              1 |      0 |                      0 |
   | 1 | 0 | 1 | 1 |    0 |    1 |              1 |      1 |                      1 |
   | 1 | 1 | 0 | 0 |    1 |    0 |              0 |      1 |                      1 |
   | 1 | 1 | 0 | 1 |    1 |    0 |              0 |      1 |                      1 |
   | 1 | 1 | 1 | 0 |    1 |    1 |              1 |      0 |                      0 |
   | 1 | 1 | 1 | 1 |    1 |    1 |              1 |      1 |                      1 |

** OTD
(p ∨ q) ∧ (¬ p ∨ r) → (q V r)
   | p | q | r | \not p | p V q | \not p V r | (p V q) V (\not p V r) | (q V r) | ((p ∨ q) ∧ (¬ p ∨ r)) → (q V r) |
   | 0 | 0 | 0 |   1 |     0 |       1 |                   1 |       0 |                               0 |
   | 0 | 0 | 1 |   1 |     0 |       1 |                   1 |       1 |                               1 |
   | 0 | 1 | 0 |   1 |     1 |       1 |                   1 |       1 |                               1 |
   | 0 | 1 | 1 |   1 |     1 |       1 |                   1 |       1 |                               1 |
   | 1 | 0 | 0 |   0 |     1 |       0 |                   1 |       0 |                               0 |
   | 1 | 0 | 1 |   0 |     1 |       1 |                   1 |       1 |                               1 |
   | 1 | 1 | 0 |   0 |     1 |       0 |                   1 |       1 |                               1 |
   | 1 | 1 | 1 |   0 |     1 |       1 |                   1 |       1 |                               1 |
** UJU
*** 1.    
    | p | q | p V q | <-> | q | p | q V p |
    | 0 | 0 |     0 |   1 | 0 | 0 |     0 |
    | 0 | 1 |     1 |   1 | 0 | 1 |     1 |
    | 1 | 0 |     1 |   1 | 1 | 0 |     1 |
    | 1 | 1 |     1 |   1 | 1 | 1 |     1 |
*** 2. 

    | p | q | p ^ q | <-> | p | q | q ^ p |
    | 0 | 0 |     0 |   1 | 0 | 0 |     0 |
    | 0 | 1 |     0 |   1 | 0 | 1 |     0 |
    | 1 | 0 |     0 |   1 | 1 | 0 |     0 |
    | 1 | 1 |     1 |   1 | 1 | 1 |     1 |
** OLH
*** 1. (p∨q)∨r≡p∨(q∨r)

| p | q | p V q | r | t V r | <-> | p V e | q V r |
| 0 | 0 |     0 | 0 |     0 |   1 |     0 |     0 |
| 0 | 0 |     0 | 1 |     1 |   1 |     1 |     1 |
| 0 | 1 |     1 | 0 |     1 |   1 |     1 |     1 |
| 0 | 1 |     1 | 1 |     1 |   1 |     1 |     1 |
| 1 | 0 |     1 | 0 |     1 |   1 |     1 |     0 |
| 1 | 0 |     1 | 1 |     1 |   1 |     1 |     1 |
| 1 | 1 |     1 | 0 |     1 |   1 |     1 |     1 |
| 1 | 1 |     1 | 1 |     1 |   1 |     1 |     1 |
*** 2. (p∧q)∧r≡p∧(q∧r)

    | p | q | p ^ q | r | t ^ r | <-> | p ^ e | q ^ r |
    | 0 | 0 |     0 | 0 |     0 |   1 |     0 |     0 |
    | 0 | 0 |     0 | 1 |     0 |   1 |     0 |     0 |
    | 0 | 1 |     0 | 0 |     0 |   1 |     0 |     0 |
    | 0 | 1 |     0 | 1 |     0 |   1 |     0 |     1 |
    | 1 | 0 |     0 | 0 |     0 |   1 |     0 |     0 |
    | 1 | 0 |     0 | 1 |     0 |   1 |     0 |     0 |
    | 1 | 1 |     1 | 0 |     0 |   1 |     0 |     0 |
    | 1 | 1 |     1 | 1 |     1 |   1 |     1 |     1 |
** UWY
*** 1. p∧(q∨r)≡(p∧q)∨(p∧r)

    | p | q | r | (q V r) | ^ p | <-> | (p ^ q) | V | (p ^ r) |
    | 0 | 0 | 0 |       0 |   0 |   1 |       0 | 0 |       0 |
    | 0 | 0 | 1 |       1 |   0 |   1 |       0 | 0 |       0 |
    | 0 | 1 | 0 |       1 |   0 |   1 |       0 | 0 |       0 |
    | 0 | 1 | 1 |       1 |   0 |   1 |       0 | 0 |       0 |
    | 1 | 0 | 0 |       0 |   0 |   1 |       0 | 0 |       0 |
    | 1 | 0 | 1 |       1 |   1 |   1 |       0 | 1 |       1 |
    | 1 | 1 | 0 |       1 |   1 |   1 |       1 | 1 |       0 |
    | 1 | 1 | 1 |       1 |   1 |   1 |       1 | 1 |       1 |
*** 2. p∨(q∧r)≡(p∨q)∧(p∨r)

    | p | q | r | (q ^ r) | V p | <-> | p V q | ^ | p V r |
    | 0 | 0 | 0 |       0 |   0 |   1 |     0 | 0 |     0 |
    | 0 | 0 | 1 |       0 |   0 |   1 |     0 | 0 |     1 |
    | 0 | 1 | 0 |       0 |   0 |   1 |     1 | 0 |     0 |
    | 0 | 1 | 1 |       1 |   1 |   1 |     1 | 1 |     1 |
    | 1 | 0 | 0 |       0 |   1 |   1 |     1 | 1 |     1 |
    | 1 | 0 | 1 |       0 |   1 |   1 |     1 | 1 |     1 |
    | 1 | 1 | 0 |       0 |   1 |   1 |     1 | 1 |     1 |
    | 1 | 1 | 1 |       1 |   1 |   1 |     1 | 1 |     1 |
** OBW
*** 1. ¬(p∨q)≡¬p∧¬q 
    
    | p | q | (p V q) | \not | <-> | \not p | ^ | \not q |
    | 0 | 0 |       0 | 1 |   1 |   1 | 1 |   1 |
    | 0 | 1 |       1 | 0 |   1 |   1 | 0 |   0 |
    | 1 | 0 |       1 | 0 |   1 |   0 | 0 |   1 |
    | 1 | 1 |       1 | 0 |   1 |   0 | 0 |   0 |

*** 2. ¬(p∧q)≡¬p∨¬q

    | p | q | (p ^ q) | \not | <-> | \not p | V | \not q |
    | 0 | 0 |       0 | 1 |   1 |   1 | 1 |   1 |
    | 0 | 1 |       0 | 1 |   1 |   1 | 1 |   0 |
    | 1 | 0 |       0 | 1 |   1 |   0 | 1 |   1 |
    | 1 | 1 |       1 | 0 |   1 |   0 | 0 |   0 |
** USL
*** 1. p∧1≡p
    
    | p | ^ 1 | <-> | p |
    | 0 |   0 |   0 | 0 |
    | 1 |   1 |   1 | 1 |
*** 2. p∨0≡p   

    | p | V 0 | <-> | p |
    | 0 |   0 |   1 | 0 |
    | 1 |   1 |   1 | 1 |
*** 3. ¬¬p≡p

    | p | \not \not | <-> | p |
    | 0 |   0 |   1 | 0 |
    | 1 |   1 |   1 | 1 |

*** 4. p∧0≡0   

    | p | ^ 0 | <-> | 0 |
    | 0 |   0 |   1 | 0 |
    | 1 |   0 |   1 | 0 |

*** 5. p∨1≡1

    | p | V 1 | <-> | 1 |
    | 0 |   1 |   1 | 1 |
    | 1 |   1 |   1 | 1 |

** OYP
   1. matches with USL.1 (idempotence)
   2. matches with USL.5 (absorption)
   3. matches with USL.2 (idempotence)
   4. matches with USL.4 (absorption)
   5. matches with USL.3 (double negation)
   
** UBV

*** 1. Winning the first round is necessary for winning the trophy

    p = winning the first round q = winning the trophy

   \not (p ^ q) = (\not p) ^ (\not q)
   
   If you lose the first round then you lose the trophy

*** 2. Winning the tournament is sufficient for winning the trophy

    p = winning the tournament q = winning the trophy

    Losing the the tournament is not sufficient for winning the trophy

*** 3. I am powerful and successful

    p = I am powerful q = successful
    \not (p ^ q) = (\not p) ^ (\not q)

    I am not powerful, or I am not successful

*** 4. You can pass or fail this test

    p = You can pass q = fail this test
    
    You can fail and you can pass this test

*** 5. Getting an A on the final exam is necessary and sufficient for passing this class

    p = Getting an A on the final exam q = passing this class

    If I get an A on the final exam, then I fail this class.
    If I do not get an A on the final exam, then I pass this class. 

** OKQ 

| p | q | r | p \leftrightarrow q | \wedge | q \leftrightarrow r | \leftrightarrow | p \leftrightarrow | q \wedge r |
| 0 | 0 | 0 |     1 | 1 |     1 | 1 |   1 |     0 |
| 0 | 0 | 1 |     1 | 0 |     0 | 0 |   1 |     0 |
| 0 | 1 | 0 |     0 | 0 |     0 | 0 |   1 |     0 |
| 0 | 1 | 1 |     0 | 0 |     1 | 1 |   0 |     1 |
| 1 | 0 | 0 |     0 | 0 |     1 | 1 |   0 |     0 |
| 1 | 0 | 1 |     0 | 0 |     0 | 1 |   0 |     0 |
| 1 | 1 | 0 |     1 | 0 |     0 | 1 |   0 |     0 |
| 1 | 1 | 1 |     1 | 1 |     1 | 1 |   1 |     1 |

** UKF

   | p | q | \not p | \leftrightarrow q | \leftrightarrow | p \leftrightarrow | \not q |
   | 0 | 0 |   1 |   0 | 1 |   0 |   1 |
   | 0 | 1 |   1 |   1 | 1 |   1 |   0 |
   | 1 | 0 |   0 |   1 | 1 |   1 |   1 |
   | 1 | 1 |   0 |   0 | 1 |   0 |   0 |

** OKL
   
| p | q | r | p V q | \wedge | \not p V r | -> | q V r |
| 0 | 0 | 0 |     0 | 0 |       1 |  1 |     0 |
| 0 | 0 | 1 |     0 | 0 |       1 |  1 |     1 |
| 0 | 1 | 0 |     1 | 1 |       1 |  1 |     1 |
| 0 | 1 | 1 |     1 | 1 |       1 |  1 |     1 |
| 1 | 0 | 0 |     1 | 0 |       0 |  1 |     0 |
| 1 | 0 | 1 |     1 | 1 |       1 |  1 |     1 |
| 1 | 1 | 0 |     1 | 0 |       0 |  1 |     1 |
| 1 | 1 | 1 |     1 | 1 |       1 |  1 |     1 |

It is a tautology

** UEZ
 (p ∧ q) ∧ ¬ r

| p | q | r | p \wedge q | \wedge | \not r |
| 0 | 0 | 0 |     0 | 0 |   1 |
| 0 | 0 | 1 |     0 | 0 |   0 |
| 0 | 1 | 0 |     0 | 0 |   1 |
| 0 | 1 | 1 |     0 | 0 |   0 |
| 1 | 0 | 0 |     0 | 0 |   1 |
| 1 | 0 | 1 |     0 | 0 |   0 |
| 1 | 1 | 0 |     1 | 1 |   1 |
| 1 | 1 | 1 |     1 | 0 |   0 |

** OYW

#+BEGIN_SRC emacs-lisp
(defun <-- (p q)
   "Conditional: p if q"
   (and p (not q))
)

(defun xor (p q)
  "Exclusive or."
  (if p (not q) q))  

  (defun --> (p q)
    "Conditional: p only if q"
    (or (not p) q))

  (defun <--> (p q)
    "Biconditional: p if and only if q"
    (and (--> p q) (--> q p)))

  (defun valid-connective (op)
    (or (eq op 'and) (eq op 'or) (eq op 'xor)
        (eq op '-->) (eq op '<-->)))
  (defun prop-eval (prop)
    (unless (and (vectorp prop)
                 (= 3 (length prop))
                 (valid-connective (elt prop 1)))
      (error "bad parameters"))
    (let* ((op (elt prop 1))
           (l (eval (elt prop 0)))
           (r (eval (elt prop 2)))
           (lval (y-or-n-p (mapconcat 'symbol-name l " ")))
           (rval (y-or-n-p (mapconcat 'symbol-name r " ")))
           (result (eval (list op lval rval))))
      (list l (list lval) op r (list rval) 'yields result)))

  ;(let* ((p [It is raining])
     ;    (q [The grass is wet])
    ;     (p-and-q [p and q]))
   ; (prop-eval p-and-q))


  ;(let* ((p [It is raining])
      ;   (q [The grass is wet])
     ;    (p-onlyif-q [p --> q]))
    ;(prop-eval p-onlyif-q ))

; BEGIN MY TRIES
; I commented them out as to only run one at a time...


  ;(let* ((p [My car runs])
   ;      (q [There is gas in the tank])
    ;     (p-onlyif-q [p <--> q]))
     ;(prop-eval p-onlyif-q))

     ;(let* ((p [I learn discrete math])
      ;      (q [I study hard])
       ;     (p-and-q [p xor q]))
        ;    (prop-eval p-xor-q))

   (let* ((p [It's cold])
          (q [It snows])
          (p-if-q [p <-- q]))
          (prop-eval p-if-q)) 
#+END_SRC

#+RESULTS:
| [It rains] | (t) | or | [It snows] | (nil) | yields | t |

** UEF
#+BEGIN_SRC emacs-lisp

(defun --> (p q)
  "Conditional: p only if q"
  (or (not p) q))

(defun <--> (p q)
  "Biconditional: p if and only if q"
  (and (--> p q) (--> q p)))

(defun valid-connective (op)
  (or (eq op 'and) (eq op 'or) (eq op 'xor)
      (eq op '-->) (eq op '<-->)))
(defun stringify (prop)
  (let* ((str (mapconcat 'symbol-name prop " ")))
    (downcase (substring str 0 (- (length str) 1)))))

(defun fancier-prompt (str)
  (let* ((prompt (concat "Is it the case that " str "? "))
         (answer (y-or-n-p-with-timeout prompt 5 t)))
    (princ (format "Given %s is %s\n" str (if answer 'true: 'false:)))
    answer))

(defun fancier-output (result l op r)
  (princ (format "It is %s that %s %s %s.\n"
                 (if result 'true 'false)
                 l op r)))

(defun prop-eval (prop)
  (unless (and (vectorp prop)
               (= 3 (length prop))
               (valid-connective (elt prop 1)))
    (error "bad parameters"))
  (let* ((op (elt prop 1))
         (l (eval (elt prop 0)))
         (r (eval (elt prop 2)))
         (lstr (stringify l))
         (rstr (stringify r))
         (lval (fancier-prompt lstr))
         (rval (fancier-prompt rstr))
         (result (eval (list op lval rval))))
    (fancier-output result lstr op rstr)))

(let* ((p [It is raining.])
       (q [The grass is wet.])
       (p-onlyif-q [p --> q]))
  (prop-eval p-onlyif-q))
#+END_SRC

#+RESULTS:
: It is true that it is raining --> the grass is wet.

In the prop-eval function, within the unless-> and conditional, you could replace the '(= 3 (length prop))' with 't',
you can then pass in any length of parameter. It may not be a valid input, but that is where you'd need to start if you wanted
to implement more complex expressions. 

** OUB
  #+BEGIN_SRC emacs-lisp
(defun <-- (p q)
"Conditional: p if q"
(and (not q) p))

(defun --> (p q)
  "Conditional: p only if q"
  (or (not p) q))

(defun <--> (p q)
  "Biconditional: p if and only if q"
  ;(and (--> p q) (--> q p))
  (or (<-- p q) (<-- q))
  ;(or (and p q) (and (not p) (not q)))
)

(defun valid-connective (op)
  (or (eq op 'and) (eq op 'or) (eq op 'xor)
      (eq op '-->) (eq op '<-->)))
(defun stringify (prop)
  (let* ((str (mapconcat 'symbol-name prop " ")))
    (downcase (substring str 0 (- (length str) 1)))))

(defun fancier-prompt (str)
  (let* ((prompt (concat "Is it the case that " str "? "))
         (answer (y-or-n-p-with-timeout prompt 5 t)))
    (princ (format "Given %s is %s\n" str (if answer 'true: 'false:)))
    answer))

(defun fancier-output (result l op r)
  (princ (format "It is %s that %s %s %s.\n"
                 (if result 'true 'false)
                 l op r)))

(defun prop-eval (prop)
  (unless (and (vectorp prop)
               (= 3 (length prop))
               (valid-connective (elt prop 1)))
    (error "bad parameters"))
  (let* ((op (elt prop 1))
         (l (eval (elt prop 0)))
         (r (eval (elt prop 2)))
         (lstr (stringify l))
         (rstr (stringify r))
         (lval (fancier-prompt lstr))
         (rval (fancier-prompt rstr))
         (result (eval (list op lval rval))))
    (fancier-output result lstr op rstr)))

(let* ((p [It is raining.])
       (q [The grass is wet.])
       (p-onlyif-q [p <--> q]))
  (prop-eval p-onlyif-q))

  
  #+END_SRC 

  #+RESULTS:
  : It is true that it is raining <--> the grass is wet.

** TODO UQY

#+BEGIN_SRC emacs-lisp
(defun not1 (x)
  (* (- x 1) -1)
)

(defun and2 (x y)
  (* x y)
)

(defun or2 (x y)
  ()
)

(defun truth-table-row-inputs (i)
  (elt [[0 0 0] [0 0 1] [0 1 0] [0 1 1]
        [1 0 0] [1 0 1] [1 1 0] [1 1 1]] i))

(defun truth-table-row-with-output (i func)
  (let* ((inputs (append (truth-table-row-inputs i) nil))
         (output (apply func inputs)))
    (apply 'vector (append inputs (list output)))))

(defun f1 (p q r)
  (or2 (and2 p q) (not1 r)))

(defun f2 (p q r)
  (and2 p (or2 q (not1 r))))

(defun f3 (p q r)
  (or2 p (and2 q r)))

(defun generate-truth-table-for (func)
  (vector (truth-table-row-with-output 0 func)
          (truth-table-row-with-output 1 func)
          (truth-table-row-with-output 2 func)
          (truth-table-row-with-output 3 func)
          (truth-table-row-with-output 4 func)
          (truth-table-row-with-output 5 func)
          (truth-table-row-with-output 6 func)
          (truth-table-row-with-output 7 func)))

(equal (generate-truth-table-for 'f1)
       [[0 0 0 1]
        [0 0 1 0]
        [0 1 0 1]
        [0 1 1 0]
        [1 0 0 1]
        [1 0 1 0]
        [1 1 0 1]
        [1 1 1 1]])
(equal (generate-truth-table-for 'f2)
       [[0 0 0 0]
        [0 0 1 0]
        [0 1 0 0]
        [0 1 1 0]
        [1 0 0 1]
        [1 0 1 0]
        [1 1 0 1]
        [1 1 1 1]])
(equal (generate-truth-table-for 'f3)
       [[0 0 0 0]
        [0 0 1 0]
        [0 1 0 0]
        [0 1 1 1]
        [1 0 0 1]
        [1 0 1 1]
        [1 1 0 1]
        [1 1 1 1]])
#+END_SRC

#+RESULTS:


* Week 2 DEF
  :LOGBOOK:
  CLOCK: [2017-09-29 Fri 22:53]--[2017-09-29 Fri 23:03] =>  0:10
  CLOCK: [2017-09-29 Fri 20:31]--[2017-09-29 Fri 21:49] =>  1:18
  CLOCK: [2017-09-29 Fri 11:44]--[2017-09-29 Fri 12:19] =>  0:35
  CLOCK: [2017-09-28 Thu 21:10]--[2017-09-28 Thu 22:40] =>  1:30
  CLOCK: [2017-09-28 Thu 15:18]--[2017-09-28 Thu 15:35] =>  0:17
  CLOCK: [2017-09-28 Thu 13:59]--[2017-09-28 Thu 15:06] =>  1:07
  CLOCK: [2017-09-27 Wed 22:29]--[2017-09-27 Wed 23:48] =>  1:19
  CLOCK: [2017-09-27 Wed 13:23]--[2017-09-27 Wed 14:09] =>  0:46
  CLOCK: [2017-09-27 Wed 11:44]--[2017-09-27 Wed 12:06] =>  0:22
  CLOCK: [2017-09-27 Wed 10:34]--[2017-09-27 Wed 11:22] =>  0:48
  CLOCK: [2017-09-26 Tue 16:05]--[2017-09-26 Tue 16:26] =>  0:21
  CLOCK: [2017-09-25 Mon 21:41]--[2017-09-25 Mon 21:57] =>  0:16
  CLOCK: [2017-09-26 Tue 14:52]--[2017-09-26 Tue 15:48] =>  0:56
  CLOCK: [2017-09-26 Tue 18:02]--[2017-09-26 Tue 18:33] =>  0:31
  CLOCK: [2017-09-26 Tue 21:51]--[2017-09-26 Tue 23:17] =>  1:26
  :END:
  :LOGBOOK:

  :END:

** Week 2 Day One

Our challenge in class was to write a function to rotate a string. Here is a JavaScript implementation:
#+BEGIN_SRC javascript
var s = '123456';
Array.prototype.rotate = function(n) {
var len = this.length;
return !(n % len) ? this.slice()
                  : this.map((e,i,a) => a[(i + (len + n % len)) % len]);
};
console.log(s.split('').rotate(2).join(''));
#+END_SRC

#+BEGIN_SRC emacs-lisp

(rot "Hello my name is" 13)
  

   #+END_SRC

** Week 2 Day Two

*** Q+A
 What is the difference between setf and fset.
 setf is more generic, it means  'set form'
 fset is specific to functions, it means "function set"
 #+BEGIN_SRC emacs-lisp
 (defun fun1 (s y) (* s y))
 (symbol-function 'fun1)
 #+END_SRC

 #+RESULTS:
 | lambda | (s y) | (* s y) |

 #+BEGIN_SRC emacs-lisp :results raw
   (symbol-function 'fun1)
 #+END_SRC

 #+RESULTS:
 nil
 #+BEGIN_SRC emacs-lisp
 (setf (symbol-function 'fun1) (lambda nil (list 1 2 3 )))
 #+END_SRC

 #+RESULTS:
 | lambda | nil | (list 1 2 3) |


*** Hints and Answers
   #+BEGIN_SRC emacs-lisp
   (get-hint 'CRC)
   #+END_SRC 


** DONE DEJ
   CLOSED: [2017-09-28 Thu 14:29]
   :LOGBOOK:
   CLOCK: [2017-09-29 Fri 15:28]--[2017-09-29 Fri 16:16] =>  0:48
   :END:
*** DONE TBD
    CLOSED: [2017-09-28 Thu 14:29]
    A function is injective if and only if is surjective, provided its domain and codomain 
    are the same size. 

** TODO DEK
*** DONE WDK
    CLOSED: [2017-09-29 Fri 14:05]

Variable immutibility
    #+BEGIN_SRC emacs-lisp
(require 'cl)
   (set 'a 'three) 
   (setq a (quote one)) ;; setq is equivalent to set, except instead of having to put a ' in front of the variable, it does it for you
   (setf b '(one two)) ;; setf is similar to setq, but it accepts forms on the left side instead of just symbols like (see the third example of setf)
   (setf a (first b)) ;; whenever you use setq, you could theoretically use setf, although stylisticly, setq is preferred for basic symbols. 
   (setf (second b) a)

(print a)

    #+END_SRC

    #+RESULTS:
    : one
    t
*** DONE TDR
    CLOSED: [2017-09-28 Thu 10:59]

I took an example code block and used it to play with this.
#+BEGIN_SRC emacs-lisp
;;(fset 'test (lambda (n) (if (evenp n) (/ n 2) (+ 1 (* 3 n)))))
(setf (symbol-function 'test) (lambda (n) (/ n 2) (+ 1 (* 3 n))))
(test 7)

#+END_SRC

#+RESULTS:
: 22

*** WDT
PVP = Predict Verify Ponder

**** Predict  

***** 1. I think the first expression will execute without a problem, returning the number 6.

***** 2. I think the second expression will have some trouble, because d is not defined.

***** 3. I think this will run into the same problem, because it is a vector

***** 4. I don't believe that lisp supports operator overloading, so I believe the 4th will fail.

***** 5. I think that this expression will have trouble evaluating, because let process the expressions in parallel, and not sequentially.

***** 6. I think this should give a proper output of 11
 
**** Verify/Ponder

***** Expression 1:
      #+BEGIN_SRC emacs-lisp
 (let ((a 1) (b 2) (c 3)) (+ a b c))
      #+END_SRC

      #+RESULTS:
      : 6
I successfully predicted the result.

***** Expression 2:
#+BEGIN_SRC emacs-lisp
  (let ((a 1) (b 2) (c 3)) (+ a b c d))
#+END_SRC

Returned an error saying that d was void

***** Expression 3: 
#+BEGIN_SRC emacs-lisp 
  (let ((a 1) (b 2) (c 3)) [+ a b c d])
#+END_SRC

#+RESULTS:
: [+ a b c d]

I was not expecting this, but I believe I understand why this happened. Reading this stack overflow post
helped me better understand how vectors work: https://stackoverflow.com/questions/4294346/difference-between-lists-and-arrays

***** Expression 4: 
#+BEGIN_SRC emacs-lisp
  (let ((a 1) (b 2) (c 3) (+ 4)) (+ a b c +))
#+END_SRC

#+RESULTS:
: 10

I found this very interesting. I did not know that 1, you could redefine operators like that. A key point here though, 
if I am correct, it is not actually overloading the operator, but saying 'if you find a + that is not the first element in a list, 
evaluate it as 4'. That's why (+ a b c +) works. Lisp reads the first item as the function to call, and evaluates the second + as 
was previously defined. 

***** Expression 5: 
#+BEGIN_SRC emacs-lisp
  (makunbound 'a)
(let ((a 1) (b 2) (c 3) (d (+ a 4))) (+ a b c d))
#+END_SRC

This returned a message saying that a was void. I believe this is due to my reasoning above, 
but my knowledge of Lisp is not currently strong enough to be sure. 

***** Expression 6:
#+BEGIN_SRC emacs-lisp 
  (let* ((a 1) (b 2) (c 3) (d (+ a 4))) (+ a b c d))
#+END_SRC

#+RESULTS:
: 11

I successfully predicted the output for this.

*** TEH
    I think that it would be possible. If you made sure to define variables before using them. Let's look at
    a modified version of the example code: 
#+BEGIN_SRC emacs-lisp
;; here's the original statement:
;;(let ((a 1) (b 2) (c 3) (d (+ a 4))) (+ a b c d))

;; let's try to change it up a bit
(let ((a 1) (b 2) (c 3))
   (let ((d (+ a 4))) (+ a b c d)))

;; I nested the let statement that defines d and adds all the variables together
;; inside the first let statement. This ensures that a is given a value before
;; trying to use it to initialize d
#+END_SRC

#+RESULTS:
: 11
*** WFC
    They behave pretty much how I would expect them to. I haven't
    seen anything that raises an eyebrow. It was important to note that
    if you with to use a combination of operators, you must nest them inside
    parantheses. Here's an FLA for you, LISP: Lots of Irritating Single Parantheses ;)

#+BEGIN_SRC emacs-lisp
(/ 24 4 3)
(* 5 4 3 2 1)
(* (+ 2 3) 2)
#+END_SRC

#+RESULTS:
: 10

Even with multiple operands, it behaves exactly as expected. It executes the operation in the order it was given. 
*** TEJ
**** assoc-string
     when using assoc-string, the key must be a string or symbol.
    
   #+BEGIN_SRC emacs-lisp
  (defun lookup-rgb (color-name)
  (rest (assoc-string color-name
               '(("red" 255 0 0) ("green" 0 255 0) ("blue" 0 0 255)))))

  (lookup-rgb "green")
   #+END_SRC 

   #+RESULTS:
   | 0 | 255 | 0 |
**** rassoc
rassoc is like the reverse assoc. Instead of searching for the car, it matches the cdr
    #+BEGIN_SRC emacs-lisp
   (defun lookup-rgb (color-range)
  (rest (rassoc color-range
               '(("red" 255 0 0) ("green" 0 255 0) ("blue" 0 0 255)))))
;; Produces nil: 
;;(lookup-rgb '(0 255 3))
;; Produces the cdr 
   (lookup-rgb '(255 0 0))
    #+END_SRC 

    #+RESULTS:
    | 255 | 0 | 0 |
**** assq
assq is also similar to assoc, but it compares using eq insteal of equal.
Go here to read the difference: https://www.gnu.org/software/emacs/manual/html_node/elisp/Equality-Predicates.html#Equality-Predicates
assq is best used when the key is a symbol, not a string

#+BEGIN_SRC emacs-lisp
   (defun lookup-rgb (color-range)
  (rest (assq color-range
               '((red 255 0 0) (green 0 255 0) (blue 0 0 255))))) 
(lookup-rgb 'red)
#+END_SRC

#+RESULTS:
| 255 | 0 | 0 |
**** more
     There are several more variations of assoc. You can find them here: https://www.gnu.org/software/emacs/manual/html_node/elisp/Association-Lists.html
*** DONE WFK
    CLOSED: [2017-09-29 Fri 15:39]
Removing the :test 'equal changes the the contents of the pretty print list to nil, as eq does not work on string literals
#+BEGIN_SRC emacs-lisp :results output
(let* ((mymap (make-hash-table :test 'equal)))
  (puthash "one" "red" mymap)
  (puthash "two" "blue" mymap)
  (puthash "three" "green" mymap)
  (pp (list (gethash "one" mymap)
            (gethash "two" mymap)
            (gethash "three" mymap)))
  (maphash (lambda (key value) (princ (format "%s : %s\n" key value))) mymap))

#+END_SRC

#+RESULTS:
: ("red" "blue" "green")
: one : red
: two : blue
: three : green
*** TER
**** Predict
     This looks similar to the map function in JavaScript, which is given an array, and executes a function
     on each element in the array. (See here for more info on JS map https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
     I would assume that morphify does something similar. Guessing from the function call to downcase, I think
     it will put each word as lowercase. 
**** Verify/Ponder
#+BEGIN_SRC emacs-lisp
(defun morphify (fun lst)
  (loop for item in lst
        collect (funcall fun item)))
(morphify (quote downcase) (quote ("THIS" "IS" "TOO" "LOUD")))
#+END_SRC

#+RESULTS:
| this | is | too | loud |
**** Part 2
#+BEGIN_SRC emacs-lisp
(defun morphifyr (fun lst)
  (if (null lst)
      nil
    (append (list (funcall fun (first lst))) (morphifyr fun (rest lst)))))

(morphifyr 'upcase '("1232142" "asdfasdf" "abcdefg"))
#+END_SRC

#+RESULTS:
| 1232142 | ASDFASDF | ABCDEFG |

First this function checks that there was a function passed to it. If not, it returns nil
Next it starts appending a list. The first element of this list is created by calling the passed function on the
car. It builds the rest of the list by calling morphify on the cdr. This recursively builds the list items and returns
a new list, thus keeping it functional!
*** WGP 

Just use the example given in the miniprimer! Append an empty list to a vector to convert it to a list.

    #+BEGIN_SRC emacs-lisp
    (defun vector-to-string(vec)
      (append vec nil))

(format "%s" (vector-to-string [a b c]))

    #+END_SRC

    #+RESULTS:
    : (a b c)
*** TODO TEU


17316


#+BEGIN_SRC javascript
// A function that counts solutions for a given predicate. 
// Takes a max number of iterations, as well as a predicate. 
// There is an optional third parameter, min, if you do not 
// wish to start counting at zero
function countSolutions(max, pred, min = 0) {
  let counter = 0;
  for (let i = min; i < max; i++) {
     pred(i) ? counter++ : null;
  }
  console.log("total",counter);
}


function teu_loops(i) {
  let val = i,
      sum = 0, 
      ones = 0;
  
  while (val) {
    if (ones > 1) {
      return false;
    }
    if (val % 10 === 1) {
      ones++;
    }
    sum += val % 10;
    val = Math.floor(val / 10);
  }
  if (sum != 17){
    return false;
  }
  return true;
}
countSolutions(1000000,teu_loops);
#+END_SRC


A non-looping solution
#+BEGIN_SRC javascript
const print = console.log

// A function that counts solutions for a given predicate. 
// Takes a starting, and max number, as well as a predicate. 
// The function also takes a count of how many times the predicate
// returns true. 
function tellen(start, max, pred, tel=0) {
  if(start >= max) {
    return tel;
  }
  pred(start) ? tel++ : null;
  return tellen(start + 1, max, pred, tel)
}

function sumDigits(number) {
    var remainder = number % 10;
    var sum = remainder;
    if(number >= 10) {
        var rest = Math.floor(number / 10);
        sum += sumDigits(rest); 
    }
    return sum;
}

function lessThanOnes(number) {
  let str = number + '';
  if(str.split('1').length > 2) {
    return false;
  }
  return true;
}

function pred(i) {
  if(sumDigits(i) === 17 && lessThanOnes(i)) {
    return true;
  }
  return false;
}


print(tellen(0,1000000, pred));
#+END_SRC
*** DONE WGW
    CLOSED: [2017-09-28 Thu 14:59]

First it checks that pre is a list and that its length is three. 
Then is creates a variable for each operator, using the nth item in the list function.
To ensure that any nested operations are caught, the prefix->infix function is called again on 
each of the operands. 
    #+BEGIN_SRC emacs-lisp
 (defun prefix->infix (pre)
  (cond ((listp pre)
         (or (= 3 (length pre)) (error "not a 3-length list"))
         (let ((operator (nth 0 pre))
               (operand1 (nth 1 pre))
               (operand2 (nth 2 pre)))
           (list (prefix->infix operand1)
                 operator
                 (prefix->infix operand2))))
        (t pre)))   
(prefix->infix '(/ 1.0 (* (+ (* 2 n) 1) (expt -1 n))))
    #+END_SRC

    #+RESULTS:
    | 1.0 | / | (((2 * n) + 1) * (-1 expt n)) |

#+BEGIN_SRC emacs-lisp
(defun prefix->infix (pre)
   (if (listp pre)
     (if (= 3 (length pre)) 
        (list 
         (prefix->infix (nth 1 pre))
         (nth 0 pre)
         (prefix->infix (nth 2 pre)))
         (error "not a 3-length list"))
      (list pre)))

(prefix->infix ')(* (/ 12 4 )(+ 3 2))

#+END_SRC

#+RESULTS:
| ((12) / (4)) | * | ((3) + (2)) |
*** TFV
#+BEGIN_SRC emacs-lisp
    
(defun infix->prefix (in)
       (cond ((listp in) (or (= 3 (length in)) (error "not a 3-length list"))
         (let ((operand1 (nth 0 in)) (operator (nth 1 in)) (operand2 (nth 2 in)))
                (list operator (infix->prefix operand1)
                 (infix->prefix operand2))))
        (t in)))
(infix->prefix '((3 * 7) + 4))
#+END_SRC

#+RESULTS:
| + | (* 3 7) | 4 |
** DONE DEL
   CLOSED: [2017-09-29 Fri 15:56]
*** WJS

Because the floor function takes the largest integer less than or equal, and the number is negative, the next lowest integer will be -x - 1. In positive division, this is 
the same effect as integer division, because if there is a decimal remainder, it will be chopped off, leaving the next lowest integer. Because negative numbers are moving
the opposite direction, you can almost imagine floor and ceiling also get negated respectively. The floor of a negative x is the ceiling of the absolute value of x, and vice versa.
*** TGE
#+BEGIN_SRC emacs-lisp
(defun compute-floor-the-hard-way (dividend divisor)
  (- (/ dividend (float divisor)) (/ (mod dividend divisor) (float divisor))))

(let* ((number (/ -13 4.0))
       (floor1 (floor number))
       (floor2 (compute-floor-the-hard-way -13 4.0)))
  (list number floor1 floor2))
#+END_SRC

#+RESULTS:
| -3.25 | -4 | -4.0 |

I'm not sure exactly what is meant by 'correct', but the compute-floor-the-hard-way returns a floating point number, not an integer,
so one could make the argument that it is not correct, as floor should return an integer.    
*** WKC
    #+BEGIN_SRC emacs-lisp 
  (defun frac-part (number)
  (- number (floor number)))

(print (frac-part 3.14159))

(defun floor2 (number)
"returns the floor of a number using the provided frac-part function defined above"
(truncate (- number (frac-part number))))

(print (floor2 3.14159))


#+END_SRC

#+RESULTS:
: 3
*** DONE THP
    CLOSED: [2017-09-29 Fri 15:56]

FLOOR
                 5
                    |              *--o
                    |           *--o
                    |        *--o
                    |     *--o 
                    |  *--o 
-5   ---------------*--o----------------5
                 *--o
              *--o  |
           *--o     |
        *--o        |
     *--o           |
                   -5

CEILING

                 5
                    |              o--*
                    |           o--*
                    |        o--*
                    |     o--* 
                    |  o--* 
-5   ---------------o--*----------------5
                 o--*
              o--*  |
           o--*     |
        o--*        |
     o--*           |
                   -5

*** WKM
**** 1. True
**** 2. True
**** 3. False
**** 4. True
**** 5. True
**** 6. True
**** 7. True
**** 8. False
**** 9. True
**** 10. True
*** TIW
    #+BEGIN_SRC emacs-lisp
(defun frac-part (number)
  (- number (floor number)))

(defun round-nearest-int (number)
   (cond 
      ((< (frac-part number) .5) (floor number))
      (t (ceiling number))
   )
)   

(round-nearest-int '1.5624) 
    #+END_SRC

    #+RESULTS:
    : 2
** DEM 
*** WNW
    An invertible function must be one-to-one. 
*** TKG
#+BEGIN_SRC emacs-lisp 
 (setq values '((x . 100) (y . 200) (z . 50)))
 (assoc 'y values)
 (rassoc '100 values)
 
#+END_SRC 

#+RESULTS:
: (x . 100)

Assoc searches by key, rassoc searches by value
An associative list is a kind of hash mapping, where each value is given a key. This creates
a one-to-one relationship which is why assoc can be inverted with rassoc.  
** DEN
*** DONE WOV
    CLOSED: [2017-10-06 Fri 10:50]
    1. a, a + d, a +2d, a + 3d... where a = 7 d = 7
    2. a, a + d, a + 2d, a + 3d... where a = 7 d = 4
    3. a, a + d, a + (d + 1), a + (d + 2), a + (d + 3) where a = 3 d = 1
    4. it is binary addition, adding one each iteration starting with 1.
    5. Fibonacci, n = n - 1 + n - 2 where n is the index in the sequence
    6. Starting with index 2, every other number is half of the one previous. ****
    7. Alternative fibonacci pattern beginning with 2,1 instead of 1, 1
    8. multiply the last index by two to find the next entry in the sequence. Where n initial is 6
    9. multiply the last index by three to find the next entry in the sequence. Where n intial is 6
    10. A sequence of prime numbers
*** TME
   This sequence is building the title of the book, Metaphors Be With You: 
   A Tireless Work On Play On Words. After 4 iterations, it adds a new letter
   to each item, spelling out the title.
   [metaph bewith youat irele metapho bewithy ouatir elessw] etc... 
** DONE DEO
   CLOSED: [2017-10-03 Tue 18:13]
*** DONE WQW
    CLOSED: [2017-10-06 Fri 10:50]
    | Predicate | Yes or No? |
    |-----------+------------|
    | list      | no         |
    | listp     | yes        |
    | integerp  | yes        |
    | vector    | no         |
    | vectorp   | yes        |
    | symbolp   | yes        |
    | zerop     | yes        |
    | evenp     | yes        |
    | oddp      | yes        |
    |           |            |
*** DONE TMZ
    CLOSED: [2017-10-03 Tue 18:13]
**** 1.
 #+BEGIN_SRC emacs-lisp :results raw
 (require 'cl)

 (defun count-gcd (max pred)
 (let ((counter 0)))
 (loop for i from 1 to max 
    sum (loop for j from 1 to max
       count (funcall pred i j))))

 (count-gcd 1000 (lambda (m n) (= 1 (gcd m n))))
 #+END_SRC

 #+RESULTS:
 608383
**** 2.  
There are infinitly many solutions to this problem as given. ax + by = c is what is known as a 
Diophantine equation. One of the rules of these equations is that if c is a multiple of the gcd(a,b), than
there are is an infinite amount of solutions. 
For the given problem where a = 3, b =4 , c=7: 
#+BEGIN_SRC emacs-lisp :results raw
(gcd 3 4)
#+END_SRC 

#+RESULTS:
1

7 is a multiple of 1, therefore, this equation does have a solution (for example, x = 1, y = 1), but it also 
implies that there is an infinite set of solutions. See http://mathforum.org/library/drmath/view/51595.html for a more
detailed explanation. 
**** 3.
#+BEGIN_SRC javascript
function checkSet(set, pred) {
  let count = 0;
  for(let i = set[0]; i < set.length; i++) {
    for (let j = set[0]; j < set.length; j++) {
      if (pred(i, j)) {
        count++;
      }
    }  
  }
  return count;
}
const set = [2,3,4,5,6,7,8,9]
console.log(checkSet(set, (i, j)=>{return ((j * i) - 1) % 11 === 0}));
#+END_SRC

If I did this correctly, there are 4.
**** 4. 
#+BEGIN_SRC javascript
// using the same function as above...
const set = [2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10 ,11 ,12 ,13 ,14 ,15 ,16 ,17 ,18, 19, 20, 21];

console.log(checkSet(set, (i, j)=>{return ((j * i) + 1) % 23 === 0}));

#+END_SRC

There are 16 pairs. 
**** 5.  
#+BEGIN_SRC javascript
// using the same checkSet function...
const set = [2,3,4,5,6,7];
console.log(checkSet(set, (i, j)=>{return ((j * i) + 1) % 9 === 0}));
#+END_SRC

** DONE DEP
   CLOSED: [2017-09-29 Fri 21:07]
*** DONE WRA
    CLOSED: [2017-09-29 Fri 21:07]
There is an elegent proof that can be found that demonstrates that 1/2 + ... 1/2^n is a convergent series. I could explain it here, 
but I fear I would not do it justice, however, I will attempt to put it in my own words. You can find a complete proof here -> https://www.quora.com/How-does-1-2-+-1-4-+-1-8-+-1-16-+-%E2%80%A6-till-infinity-have-a-sum

We know that because we are dealing with fractions, an infinite sum of smaller and smaller pieces will eventually approach a limit of some number. 
We can for all intents and purposes call this limit the sum, as given an infinite amount of iterations, it will would reach it. This is why some infinite series
can have finite sums. I encourage you to read the full proof, as it can explain it much better than I can; I am not a mathematician yet \smiley.
*** TNL
    The counterpart of \sum is \Pi or Pi (uppercase) The notation is the same
as sigma, but the terms are multplied instead of added. 
*** DONE WRD
    CLOSED: [2017-09-29 Fri 20:40]
    :PROPERTIES:
    :ORDERED:  t
    :END:
#+BEGIN_SRC emacs-lisp
(require 'cl)

(loop for i from 0 to 10
   sum (loop for j from i to 5
      sum (* j 2 i)))


(loop for i from 0 to 10
   sum (loop for j from 0 to i
      sum (* i (+ 5 (- i j))))) 


#+END_SRC

#+RESULTS:
: 490

*** TNQ

I found the measure-time macro on an elisp mailing list \smiley 
    #+BEGIN_SRC emacs-lisp
    (defmacro measure-time (&rest body)
  "Measure the time it takes to evaluate BODY."
  `(let ((time (current-time)))
     ,@body
     (message "%.06f" (float-time (time-since time)))))

(defun calculate-pi-very-slowly (max-iterations)
  (* 4 (loop for n from 0 to max-iterations
             sum (/ 1.0 (* (+ (* 2 n) 1) (expt -1 n))))))

;(measure-time (calculate-pi-very-slowly 5000000))
 (calculate-pi-very-slowly 5000000)

    #+END_SRC

    #+RESULTS:
    : 3.1415928535897395

Based on the approach that this method is using, and considering the fact that \pi is an irrational number, 
I'm not convinced that this will EVER give you pi. It would take an infinite amount of iterations. Just to get
to the point above took about a minute and 20 sec on a pretty powerful laptop, and it's still not even accurate 
past 10^-6 power. 

** DONE DEV
   CLOSED: [2017-10-06 Fri 21:43]

*** WRP
   
**** ∃ x P(x)
     There exists in x such that x is 21
**** ∀ x P(x)
     Every person the domain of all people is 21
**** ∃ x ¬ P(x)
     There exists in x such that someone is NOT 21
**** ∀ x ¬ P(x)
     No person is 21
*** TOJ
**** ∃ x S(x)
There are residents of Idaho who are students at BYU-Idaho
**** ∀ x S(x)
All residents of Idaho are students at BYU-Idaho
**** ¬∃ x S(x)
There are no residents of Idaho who are students at BYU-Idaho
**** ∃ x ¬ S(x)
There are residents of Idaho who are not students at BYU-Idaho
**** ¬∀ x ¬ S(x)
Some residents of Idaho are BYU-Idaho students
**** ∀ x ¬ S(x)
No residents of Idaho are BYU-Idaho students
*** WRU
**** ∀ x (F(x) → C(x))
Every friend is cool
**** ∃ x (F(x) ∧ C(x))
There are friends that are cool
**** ∀ x (F(x) ∧ C(x))
In the reading, it says that this should be written as  ∀ x (F(x) → C(x))
which means that every friend is cool
**** ∃ x (F(x) → C(x))
This is also expressed incorrectly according to section DEV, it should be
 ∃ x (F(x) ∧ C(x)) which means that there are friends that are cool
*** TOL
**** ∀ x (S(x) → R(x))
All students are from Russia
**** ∃ x (R(x) → R(x))
Should be written as  ∃ x (S(x) ∧ R(x))
There are students who are from Russia
See DEV
**** ∀ x (S(x) ∧ R(x))
Should be written as  ∀ x (S(x) → R(x)) See DEV
and means All students are from Russia
**** ∃ x (S(x) ∧ R(x))
There are students who are from Russia
*** WZO
**** Everyone’s a critic.
     \forall x (S(x)) where S(x) = x is a critic and the domain is all people
**** No one is perfect.
     \forall x \not (S(x)) where S(x) = x is perfect and the domain is all people
**** At least one of your friends is perfect.
     \exists x (S(x)) where S(x) = x is perfect and the domain is friends
**** All of your friends are critics.
     \forall x (S(x)\rightarrow C(x)) where S(x) = x is your friend and C(x) = x is a critic and the domain is all people
**** Everyone is a critic or someone is your friend.
    \forall x (C(x))\vee \exist x (S(x)) where C(x) = x is a critic and S(x) = x is your friend
**** No one is a critic and everyone is your friend.
     \not \exists x (C(x)) \wedge \forall x (S(x)) where C(x) = x is a critic and S(x) = x is your fr
*** TOUc
**** All horses have hooves
     \forall x (H(x)->h(x)) where H(x) = x is a horse and h(x) = x has hooves
     \exists X (H(x) V \not h(x))
     
     There exists a horse that does not have hooves
**** No horses can fly
     \forall x (H(x)->f(x)) where H(x) = x is a horse and f(x) = x cannot fly
     \exists x (H(x) V \not f(x)) 
     There exist some horses who can fly. 
**** Every bat is blind
     \forall x (B(x)->b(x)) where B(x) = x is a bat, and b(x) = x is blind
     \exists x (B(x) V \not b(x))
     There exists a bat which is not blind
**** TODO No bear can dance
     \forall x (B(x)->d(x)) where B(x) = x is a bear and d(x) = x can't dance
     \exists x (B(x) V \not d(x)) 
      There exists a bear which can dance. 
**** There is at least one penguin that can swim and catch fish
    \exists x (P(x) \wedge S(x)\wedge C(x) )  S(x) = x can swim and C(x) = x can catch fish
    \forall x (\not P(x) V \not S(x) V \not C(x)) 
    There are no pengiuns that can swim or catch fish
* Week 3 DEF PT2 
  :LOGBOOK:
  CLOCK: [2017-10-06 Fri 16:20]--[2017-10-06 Fri 17:53] =>  1:33
  CLOCK: [2017-10-06 Fri 10:44]--[2017-10-06 Fri 11:15] =>  0:31
  CLOCK: [2017-10-05 Thu 22:03]--[2017-10-05 Thu 23:33] =>  1:30
  CLOCK: [2017-10-05 Thu 20:22]--[2017-10-05 Thu 21:26] =>  1:04
  CLOCK: [2017-10-05 Thu 14:52]--[2017-10-05 Thu 15:42] =>  0:50
  CLOCK: [2017-10-03 Tue 19:10]--[2017-10-03 Tue 20:36] =>  1:26
  CLOCK: [2017-10-03 Tue 16:00]--[2017-20-03 Tue 18:15] =>  2:15 
  :END:
** Week 3 Day One
*** Remedies   
*** Do Hard Things
**** Let and Lambda
** Week 3 Day Two   
*** In class exercise
**** Code
   #+BEGIN_SRC emacs-lisp
   (get-answer 187434316 'ujf)
   #+END_SRC

   #+RESULTS:
     The limiting radius (r_\infty) of the outermost circle is 8.700
     (approximately).

     There are reasons finding the value of this radius is an exercise/problem in
     /discrete/ mathematics (one is because algorithms are step-by-step discrete
     things, another is that the answer can only be given with finite precision,
     which is a discrete math idea) and there are reasons for it being /continuous/
     mathematics (because you can do it without a computer, and the answer is a
     /real/ number, which is a continuous math idea). In other words, it depends!

     Whether or not this was an exercise (versus a problem) depends on if on first
     contact you immediately knew how to answer it or not!

     Below are two computational solutions to this problem, one in C++, one in
     elisp. A good exercise of your thinking and writing skills would be to compare
     and contrast the two, bearing in mind that to be responsive at all there
     should be at least one point of comparison (telling how they are the same) and
     at least one point of contrast (telling how they are different), and
     preferably two or more of each.

     

    #+BEGIN_SRC C++ :var num=10000000 :results output
      #include <iostream>
      #include <iomanip>
      #include <cmath>
      #include <ctime>
      #include <cstdlib>
      using namespace std;

      double limitingRadius(long numSides)
      {
         double radius = 1.0;
         for (long i = 3; i < numSides; i++)
         {
            radius /= cos(M_PI / i);
         }
         return radius;
      }

      int main(int argc, const char* argv[])
      {
         int n = (argc < 2) ? num : atol(argv[1]);
         clock_t start = clock();
         double result = limitingRadius(n);
         clock_t end = clock();
         cout << "Calculated " << setprecision(17) << result
              << " with " << num << " iterations in "
              << (end - start) / (double) CLOCKS_PER_SEC
              << " seconds.\n";
         return 0;
      }
    #+END_SRC

    #+RESULTS:

    #+BEGIN_SRC emacs-lisp :results raw
      (defun limiting-radius (num-sides)
        (loop with result = 1.0
              for i from 3 below num-sides
              do (setq result (/ result (cos (/ pi i))))
              finally return result))

      (defun calculate-limiting-radius (num-sides)
        (let* ((start (float-time))
               (result (limiting-radius num-sides))
               (end (float-time)))
          (format "Calculated %.17f with %d iterations in %.17f seconds."
                  result num-sides (- end start))))
    #+END_SRC

    #+RESULTS:
    calculate-limiting-radius

    #+BEGIN_SRC emacs-lisp
      (calculate-limiting-radius 100000)
    #+END_SRC

    #+RESULTS:
    : Calculated 8.69960730405618676 with 100000 iterations in 0.54544758796691895 seconds.

    #+BEGIN_SRC emacs-lisp
      (calculate-limiting-radius 1000000)
    #+END_SRC

    #+RESULTS:
    : Calculated 8.69999369233345732 with 1000000 iterations in 0.36726808547973633 seconds.

    #+BEGIN_SRC emacs-lisp
      (calculate-limiting-radius 10000000)
    #+END_SRC

    #+RESULTS:
    : Calculated 8.70003233192909420 with 10000000 iterations in 3.98808026313781738 seconds.

    #+end_example

**** Similarties
***** The algorithm is essentially the same in lisp and C++. The limited radius is calculated dividing the radius by cosine of pi over the iteration. 
***** They are both calculating the result procedurally with a for loop instead of recursively (which would be more functional)
**** Differences
***** elisp is much more verbose than c++. Consider the for loop. The for loop in elisp is written very similarly to how you 
      would explain a for loop to someone who is unfamiliar with the concept.
***** C++ is taking the number of iterations from the command line arguments, while elisp is using a function call with parameter. 
***** C++ has to include several more libraries, while they are included in elisp
***** C++ is strongly typed, while elisp variables are 'dynamic'
** DONE DEV
   CLOSED: [2017-10-06 Fri 16:28]
   :LOGBOOK:
   CLOCK: [2017-10-05 Thu 22:02]--[2017-10-05 Thu 22:03] =>  0:01
   :END:
*** WYH
**** 1. 
     \exists x (C(x) \wedge a(x)) where x is a song C(x) = x can be sung a(x) = there is a soul alive
**** 2.
     \forall x (m(x)) where x the set of all errors m(x) = displays an error
**** 3.
     \exists x (P(x) \wedge V(x)) where x is the set of scanned programs. P(x) = x is a program, V(x) = x has a virus
*** TLI
    1. False. There are many integers greater than
    2. True.
    3. True.
    4. False
*** DONE WPI
    CLOSED: [2017-10-06 Fri 16:28]
    1. True
    2. False
    3. True
    4. True
*** TSD
1. \exists x (E(x) \wedge \not L(x) \wedge \not R(x))
2. \exist x (L(x) \wedge R(x))
3. \exists x (E(x) \wedge \not R(x))
4. \exists x (E(x) \wedge L(x))
*** WTM
    1. \not \exists x (L(x) \wedge D(x))
    2. \forall x (S(x)->D(x))
    3. \forall x (F(x) -> L(x))
    4. \not \exists (F(x)\wedge S(x))
    5. Yes it does.
*** TTV
    1. True cube root of -9 is approx -2.08
    2. True
    3. True
    4. True
*** DONE WUZ
    CLOSED: [2017-10-06 Fri 16:20]
    :LOGBOOK:
    CLOCK: [2017-10-06 Fri 16:20]--[2017-10-06 Fri 17:53] =>  1:33
    :END:

#+BEGIN_SRC emacs-lisp :results raw
(defun is-true-even (x)
   (= 0 (% x 2)))

(defun is-false-even (x)
   (not (is-true-even x)))

(defun is-true-odd (x)
   (not (is-true-even x)))

(defun is-false-odd (x)
   (is-true-even x))

(defun for-all (set func)
   (loop for i in set
      always (funcall func i)))

(defun for-some (set func)
   (loop for i in set
      thereis (funcall func i)))

(for-all '(3 1 7 8) 'is-true-even)

#+END_SRC

#+RESULTS:
nil
t
t
nil

** DEW
*** WZM
**** Injective
     \forall a,b \in X
**** Surjective
     \forall y \in \exists x \in X 
*** TUK 
**** 1. ∃ x ∀ y (x > y)
     There exists an X that is greater than all y. False?
**** ∃ x ∃ y (((x ≥ 0) ∧ (y ≥ 0)) → (xy ≥ 0))
     There exists an x and a y that if x is greater than or equal to 0  and y is greater than or equal to zero, then x multiplied by y is greater than zero. This is true.
****  ∃ x ∀ y ∃ z (x = y + z)
     There exists an x and z for all y that x equals y plus z.
*** WVQ
Let Q(x, y) be the statement “x asks y a question,” where the domain for both x and y consists of all students in a class. Express each quantification in an English sentence.
**** 1. ∀ x ∃ y Q(x, y)
    All students ask at least one other student a question in a class 
**** 2. ∀ x ∀ y Q(x, y)
     All students ask all other students a question in a class
**** 3. ∃ x ∃ y Q(x, y)
     Some students ask some other students a question in class
**** 4. ∃ x ∀ y Q(x, y)
     Some students ask all other students a question in class
**** 5. ∀ y ∃ x Q(x, y)
     All students are asked a question by some students in a class
**** 6. ∃ y ∃ x Q(x, y)
     Some students are asked a question by some students in the class
*** DONE TUQ
    CLOSED: [2017-10-06 Fri 16:36]
**** 1.
     \not \forall x \forall y Q(S(x),T(y))
**** 2. 
     \exists x \exists y Q(S(x), T(y))
**** 3. 
     \forall x \exists y (Q(S(x), T(y))) \wedge (Q(S(x), A(x)))
**** 4. 
     \exists x \exists y Q((S(x) \wedge (x \ge 2)), T(y))
*** WVU 
    x is a teacher and y is a class
**** 1. 
     \not\exists x \forall y T(x, y)
**** 2.
     \forall x \forall y T(x, y)
**** 3.
    \exists x \forall y (T(x, y) \wedge (x \ge 2) 
**** 4.
    \not \exists x \forall y T(x, y)
*** DONE TUW
    CLOSED: [2017-10-06 Fri 17:22]
    1. Every CS Major needs to take discrete mathematics
       T(x,y) = x must take y
       C(x) = x is a computer science major
       \forall x (C(x)-> T(x, Discrete Math))
    2. Every student in the class owns a laptop 
       domain is student in the class
       O(x, y) x owns y. 
       \forall x O(x, laptop)
    3. There is a student in the class that has taken data structures.
       D(x,y) = x has taken y
       \exists x D(x, Data Structures)
    4. No student has been in every building at the University
       The domain is all students and buildings at the University.
       F(x, y) x has been in y S(x) x is a student B(x) x is a building
       \not \forall x \forall y F(S(x), B(x))
    5. Exactly one student has been in every room in the STC
       The domain is all students and buildings
       F(x,y) x has been in y. S(x) x is a student B(x) x is the STC
       \exists! x F(S(x), B(x))
    6. \forall x \exists y \forall z F(x,y,z) x has been in room y in building z 
*** WWD
*** TVL
    1. Jackon Andrews dropped out of Discrete Mathematics.
    2. There is a student who has dropped out of all classes
    3. All students have dropped out of a class
*** WWR
    1. \forall x \exists y ( (x + y)/2 <= x <= y) )
    2. \forall x \forall (x * -y < 0)
    3. \not \exists x F(x) where F(x) = x can be divided by 0
    4. \forall x (F(x) > 0) where F(x) = x is a positive number
*** TWN
    \not \exist x P(x)\wedge F(x) P(x) x is a prime number and F(x) = x has 3 factors
*** WWS 
    1. True
    2. True
    3. True
    4. True
*** TXG
    1. True
    2. False
    3. True
    4. True
    5. True
    6. False
    7. False
    8. True
*** WZG
    1. All real numbers
*** DONE TKH
    CLOSED: [2017-10-06 Fri 21:37]
#+BEGIN_SRC emacs-lisp :results raw
(defun is-true-even (x)
   (= 0 (% x 2)))

(defun is-false-even (x)
   (not (is-true-even x)))

(defun is-true-odd (x)
   (not (is-true-even x)))

(defun is-false-odd (x)
   (is-true-even x))

(defun for-all (set func)
   (loop for i in set
      always (funcall func i)))

(defun for-some (set func)
   (loop for i in set
      thereis (funcall func i)))

(defun for-all-for-all (x y pred)
   (loop for i in x
     always (loop for j in y
         always (funcall pred i j))))

(defun for-some-for-some (x y pred)
    (loop for i in x
       thereis (loop for j in y
          thereis (funcall pred i j))))

(defun for-all-for-some (x y pred)
    (loop for i in x
        always (loop for j in y
           thereis (funcall pred i j))))

(defun for-some-for-all (x y pred)
   (loop for i in x
      thereis (loop for j in y
         always (funcall pred i j))))

(defun x-greater-y (x y)
(> x y))

;;(for-all '(3 1 7 8) 'is-true-even)
;;(for-all-for-all '(9 9 9 9 9 9) '(10 2 3 4 5 6 7) 'x-greater-y)
;;(for-some-for-some '(1 2 3 4) '(5 1 7 8) 'x-greater-y)

#+END_SRC   

#+RESULTS:
t
nil
nil
nil
t


*** WUE
    ∀x∃yP(x,y)

    Stated in English this would say that for all blessings x there exists a law y.
    This is almost identical to how the scripture is worded. 

* Week 4 GHI
  :LOGBOOK:
  CLOCK: [2017-10-14 Sat 12:21]--[2017-10-14 Sat 12:53] =>  0:32
  CLOCK: [2017-10-13 Fri 20:55]--[2017-10-13 Fri 22:09] =>  1:14
  CLOCK: [2017-10-13 Fri 20:04]--[2017-10-13 Fri 20:18] =>  0:14
  CLOCK: [2017-10-12 Thu 21:38]--[2017-10-12 Thu 22:01] =>  0:23
  CLOCK: [2017-10-12 Thu 18:18]--[2017-10-11 Thu 18:46] =>  0:28
  CLOCK: [2017-10-11 Wed 20:42]--[2017-10-11 Wed 22:50] =>  2:08
  CLOCK: [2017-10-10 Tue 21:09]--[2017-10-10 Tue 22:19] =>  1:10
  CLOCK: [2017-10-10 Tue 15:53]--[2017-10-10 Tue 17:17] =>  1:24
  :END:

** Week 4 Day One

*** Discuss DeMorgan's Laws
    
**** For Propositional Logic
     
     A negation of a disjunction/conjuction \equiv conjunction/disjunction of the negations


***** How do you negate a conditional? (p -> q)?
      
      (p \rarr q) \equiv \not p \lor q
      \not (p \rarr q) \equiv \not (\not p \lor q) \equiv (p \wedge \not q)
      
**** For Quantfiers
     
***** A Small Universe
      \forall x Even(x)
      
      Consists of two elements:  [2, 4]
      \forall x Even(x) \equiv Even(2) \wedge Even(4) ...

      \forall x Even(x) \equiv Even(2) \land Even(4)

      \not \forall Even(x) \equiv \not (Even(2) \land Even(4)) \equiv \not Even(2) \lor \not Even(4)

      \exists x \not Even(x) \equiv \not Even(2) \lor \not Even(4)

      \exists x LessThan(x, 4) \equiv lessThan(2, 4) \lor lessThan(4,4)

      \not \exist x LessThan(x, 4) \equiv \not (lessThan(2, 4) \lor lessThan(4,4)) \equiv \not LessThan(2, 4) \land \not LessThan(4,4) \equiv \forall x \not LessThan(x,4)

      Not All  does not mean not none, it means some not. 
      Not Some does not mean All. It means All Not, or none. 

***** What Say

      
****** Axioms of Real Numbers
       
       - Trichotomy \rarr one (and only one) of these three statements is true:
         * x < y
         * x = y
         * x > y

           x < 0 means x is a negative number
           x > 0 means x is a positive number
           x \ge 0 means x is a non-negative number
           x \le 0 means x is a non-positive number
       
****** The product of two negatives is positive

****** The mean of two positive numbers is positive

****** The difference of two negative numbers is negative. False.
       If y is more negative than x, e.g., -4 < -3.

       
******* Negation
        \not \forall x \forall y [(x < 0) \land (y < 0) \rarr (x-y < 0)] \equiv
        \exists x \not \forall y [(x < 0) \land (y < 0) \rarr (x-y < 0)] \equiv
        \exists x \exists y \not [(x < 0) \land (y < 0) \rarr (x-y < 0)] \equiv
        \exists x \exists y [(x < 0) \land (y < 0) \land (x-y \ge 0)]. True. 

*** Questions 
    
**** How many possible binary realtions are there on a set with 3 elements?
     Relation: A binary relation is a SUBSET of A x A (Cartesian product)

     A = [1 2 3] 
     A x A = [ [1 1] [1 2] [1 3] [2 1] ...] 
     if A is size n, then the size of A x A = n^2

     How many subset are there of a set of size m? 2^m

     How many subsets are there of a set with n^2 elements? 2^{n^2}
** Week 4 Day Two
   What does Polyadic mean in the context of functin arity classification?

   I propose that we take it ot mean a function that takes ZERO or more arguments

#+BEGIN_SRC emacs-lisp :results raw append
(list 1 2 3 4 5 3 7)
#+END_SRC

#+RESULTS:
** DONE GHL
   CLOSED: [2017-10-11 Wed 20:51]

*** EBQ
I posted about this in the Slack channel, it was kind of hard to explain without the code, 
so I tried to comment this the best I could. I'm still not a lisp expert, so these comments 
are based on what I understand to be happening based on the documentation that I have read. 
#+BEGIN_SRC emacs-lisp :results silent
(defun cartesian-product (x y)
  (mapcan (lambda (x-item) ;; map over the first list
      (mapcar (lambda (y-item) ;; map over the second list
          (if (listp x-item) ;; check that we are given a list 
            (append x-item (list y-item)) ;; if so, append the y-item 
            (list x-item y-item))) ;; otherwise, list the two items
       y)) ;; passing y into the nested map
   x)) ;; passing x into the map

(defun cartesian-product-general (list-of-sets)
   (reduce #'cartesian-product list-of-sets)) 
;; caling the reduce function on the cartesian-product 
;; reduce will go through the list-of-sets, evaluate the function
;; on the first two, and then evaluate it again with the first result and 
;; the third element so on until it runs out of sets. 

#+END_SRC
#+BEGIN_SRC emacs-lisp
(cartesian-product-general '((a b c d) (1 2) (x y z w t) (h i j)))

;; I deleted the results, as the resulting table is quite large :) If you run it, it will work. 
#+END_SRC


*** MGX
    #+BEGIN_SRC emacs-lisp :results silent
    (defun map-for-all (pred x domain-y)
  (every (lambda (y) (funcall pred x y)) domain-y))
    #+END_SRC

#+BEGIN_SRC emacs-lisp :results silent
(defun map-for-all-for-all (pred domain-x domain-y)
  (every (lambda (x) (map-for-all pred x domain-y)) domain-x))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(map-for-all-for-all '< [1 2 3] [4 5 6])
#+END_SRC

#+RESULTS:
: t


*** DONE ECI
    CLOSED: [2017-10-11 Wed 20:51]
TODO: Example predicates... 
#+BEGIN_SRC emacs-lisp :results raw
(defun map-for-some (pred x domain-y)
   (some (lambda (y) (funcall pred x y)) domain-y))

(defun map-for-some-for-some (pred domain-x domain-y)
   (some (lambda (x) (map-for-some pred x domain-y)) domain-x))

(defun map-for-some-for-all (pred domain-x domain-y)
   (some (lambda (x) (map-for-all pred x domain-y)) domain-x))

(defun map-for-all-for-some (pred domain-x domain-y)
   (every (lambda (x) (map-for-some pred x domain-y)) domain-x))

;;(map-for-some-for-all '< [1 2 0] [1 2 8])
;;(map-for-some-for-all '> [1 2 0] [5 6 5])
;;(map-for-some-for-all '= [1 2 0] [5 6 7])
#+END_SRC

** DONE GHM
   CLOSED: [2017-10-11 Wed 20:48]

*** DONE MHB
    CLOSED: [2017-10-11 Wed 20:48]
    ∀ x ∀ y [xRy ∧ yRx → x = y]  let p = (xRy \land yRx) and q = (x = y) 
    The implication is that if x is related to y, and y is related to x, then x is equal to y (p->q).
    So if xRy is true, but does not imply q, then yRx must be false for the implication to remain valid. 
   
*** ECT

#+BEGIN_SRC emacs-lisp :results raw
(defun in-the-relation (x y)
  (> x (+ y 1)))
#+END_SRC
    R = [(3 1) (4 1) (4 2)]

*** MKJ
https://math.stackexchange.com/questions/235972/transitive-relations
    * Not relexive (No (3 3))
    * It is symmetric
    * It is not antisymmetric
    * It is transitive

     So this is a symmetric transitive relation
    

*** EFE
https://math.stackexchange.com/questions/235972/transitive-relations
    * It is reflexive
    * It is not symmetric
    * It is antisymmetric
    * It is transitive
It is a reflexive antisymmetric transitive relation

*** MKL
    * It is not reflexive
    * It is symmetric
    * It is not antisymmetric
    * It is not transitive because there is no (1 1)
This is a symetric relation

*** EFS
    1. It is not reflexive
    2. It is not symmetric
    3. It is antisymmetric - vacuously -> There are no symmetric pairs
    4. It is not transitive

This is an antisymmetric relation






*** MLB
#+BEGIN_SRC emacs-lisp
 (defun number-of-binary-relations (n)
    (* n n))

(number-of-binary-relations '10)
#+END_SRC

#+RESULTS:
: 100

** DONE GHN
   CLOSED: [2017-10-14 Sat 12:53]

*** DONE EJE
    CLOSED: [2017-10-12 Thu 11:53]
   
#+BEGIN_SRC emacs-lisp :results raw
(setq students [1 2 3 4 5 6 7 8]
      courses [100 200 300 400]
      by-student '((1 100 200)
                   (2 100)
                   (3 100 200 300)
                   (4 100 200 300 400)
                   (5 100)
                   (6 100)
                   (7 100 200)
                   (8 100 200 300 400))
      by-course '((100 1 2 3 4 5 6 7 8)
                  (200 1 3 4 7 8)
                  (300 3 4 8)
                  (400 4 8)))

(defun student-has-taken-course (student course)
  (not (null (member course (rest (assoc student by-student))))))

(defun course-has-been-taken-by-student (course student)
  (not (null (member student (rest (assoc course by-course))))))


;; similar to the for-all-for-all function, but returns a list of
;; domain-x, saying whether it was true for all across domain-y
(defun all-courses (pred domain-x domain-y)
   (loop for i across domain-x 
     collect (list i (loop for j across domain-y
        always (funcall pred i j)))))



(all-courses 'course-has-been-taken-by-student courses students)
#+END_SRC

#+RESULTS:
((100 t) (200 nil) (300 nil) (400 nil))
((1 nil) (2 nil) (3 nil) (4 t) (5 nil) (6 nil) (7 nil) (8 t))

#+BEGIN_SRC emacs-lisp :results raw
(mapcar 'first by-student)

#+END_SRC

#+RESULTS:
(1 2 3 4 5 6 7 8)
((1 100 200) (2 100) (3 100 200 300) (4 100 200 300 400) (5 100) (6 100) (7 100 200) (8 100 200 300 400))

*** DONE MLU
    CLOSED: [2017-10-14 Sat 12:53]
    
    I tried to get it working in lisp, but I ran out of time, so I just built it in JavaScript :) I might come back later and attempt to 
    translate the JavaScript into lisp. 

#+BEGIN_SRC emacs-lisp :results output
(setq birthday-table [[Bill 1992 Jan 1] [Bob 2001 May 13][Sue 2000 Dec 22] [George 1995 Sep 17] [Maia 1994 May 12]]
      zodiac-table [[Jan 20 Aquarius] [Feb 19 Pisces] [Mar 21 Aries] [Apr 20 Taurus] [May 21 Gemini] [Jun 21 Cancer] [Jul 23 Leo] [Aug 23 Virgo] [Sep 23 Libra] [Oct 23 Scorpio] [Nov 22 Sagittarius] [Dec 22 Capricorn]]
      months-assoc '((Jan . 01) (Feb . 02) (Mar . 03) (Apr . 04) (May . 05) (Jun . 06) (Jul . 07) (Aug . 08) (Sep . 09) (Oct . 10) (Nov . 11) (Dec . 12)))

(defun join-zodiac (s1 s2)
  (loop for i across s1
    append (loop for k across s2 
       until (> (cdr (assoc (elt i 2) months-assoc)) (cdr(assoc (elt k 0) months-assoc)))
          do (princ (list(elt i 0) (cdr(assoc (elt k 0) months-assoc)))))))

(join-zodiac birthday-table zodiac-table)
;;(elt (elt birthday-table 2) 2)
#+END_SRC

#+RESULTS:
: (Bill 1)(Bill 2)(Bill 3)(Bill 4)(Bill 5)(Bill 6)(Bill 7)(Bill 8)(Bill 9)(Bill 10)(Bill 11)(Bill 12)
nil

#+BEGIN_SRC js :results output

const birthday_table = [["Bill", 1992, "Jan", 1], ["Bob", 2001, 'May', 13], ['Sue', 2000, 'Dec', 22], ['George', 1995, 'Sep', 17], ['Maia', 1994, 'May', 12]]
const zodiac_table = [['Jan', 20, 'Aquarius'], ['Feb', 19, 'Pisces'], ['Mar', 21 ,'Aries'], ['Apr', 20, 'Taurus'], ['May', 21, 'Gemini'], ['Jun', 21, 'Cancer'], ['Jul', 23, 'Leo'], ['Aug', 23, 'Virgo'], ['Sep', 23 ,'Libra'] ,['Oct' ,23, 'Scorpio'], ['Nov', 22, 'Sagittarius'],['Dec', 22, 'Capricorn']];
const month_map = {
  'Jan': 0,
  'Feb': 01,
  'Mar': 02,
  'Apr': 03,
  'May': 04,
  'Jun': 05,
  'Jul': 06,
  'Aug': 07,
  'Sep': 08,
  'Oct': 09,
  'Nov': 10,
  'Dec': 11
};

let zodiacs = [];

birthday_table.forEach((birthel)=>{
  const bmonth = month_map[birthel[2]];
  const bday = birthel[3];
  if(bday >= zodiac_table[bmonth][1]) {
    zodiacs.push([birthel, zodiac_table[bmonth][2]]);
  } else {
    //const adjusted_bmonth;
    if(bmonth - 1 < 0) {
      const adjusted_bmonth = 11
      zodiacs.push([birthel, zodiac_table[adjusted_bmonth][2]])
    } else {
      const adjusted_bmonth = bmonth-1;
      zodiacs.push([birthel, zodiac_table[adjusted_bmonth][2]])
    }
  }
});

zodiacs.forEach((el)=>{
  console.log(el); 
});
#+END_SRC

#+RESULTS:
: [ [ 'Bill', 1992, 'Jan', 1 ], 'Capricorn' ]
: [ [ 'Bob', 2001, 'May', 13 ], 'Taurus' ]
: [ [ 'Sue', 2000, 'Dec', 22 ], 'Capricorn' ]
: [ [ 'George', 1995, 'Sep', 17 ], 'Virgo' ]
: [ [ 'Maia', 1994, 'May', 12 ], 'Taurus' ]

*** DONE EJK
    CLOSED: [2017-10-13 Fri 20:55]

#+NAME: example-table
| a   | b   |  c |
| 12  | 23  | 42 |
| YOU | ARE | A  |

#+BEGIN_SRC emacs-lisp :var example-table=example-table
(list example-table)
#+END_SRC

#+RESULTS:
| (a b c) | (12 23 42) | (YOU ARE A) |

** GHQ
*** MMC
    | Set Name | Equiv Class | Lesser Members |     |     |    | \downarrow |    |    |    | Greater Members |
    | A_0       | [0]         | ...            | -21 | -14 | -7 | 0 |  7 | 14 | 21 | ...             |
    | A_1       | [1]         | ...            | -20 | -13 | -6 | 1 |  8 | 15 | 22 | ...             |
    | A_2       | [2]         | ...            | -19 | -12 | -5 | 2 |  9 | 16 | 23 | ...             |
    | A_3       | [3]         | ...            | -18 | -11 | -4 | 3 | 10 | 17 | 24 | ...             |
    | A_4       | [4]         | ...            | -17 | -10 | -3 | 4 | 11 | 18 | 25 | ...             |
    | A_5       | [5]         | ...            | -16 |  -9 | -2 | 5 | 12 | 19 | 26 | ...             |
    | A_6       | [6]         | ...            | -15 |  -8 | -1 | 6 | 13 | 20 | 27 | ...             |
*** EJU
    I would say that the CMM relation would be (mod i 10)
*** MNE
Consider the set of all bitstrings having length at least 3. 
Show that the relation on this set that says two bitstrings are related if they agree in the first three bits is an equivalence relation

An equivalence relation is one which is reflexive, symmetric, and transitive.

The set is reflexive because, if the first three bits agree then there will be instances of a = a

The set is symmetric because, if the first three bits of a agree with b, then the first three bits of b agree with a, so it is symmetric.

The set is transitive because, if the first three bits of a agree with the first three bits of b, and b agrees with c, then a will agree with c.
** GHR
*** EKQ


   1. No, because it is not reflexive, I am not my own sibling.
   2. Yes
   3. No, because it may not always be transitive. I may share a parent with my half-brother, who shares a parent with his half-sister.
      That does not mean that his half-sister and I share the same parent.
   4. No, it is not always transitive. Example: I speak Dutch, which I share in common with my Father. My Father speaks German with his boss. 
      I do not speak German, so I do not have a relation with my Father's boss. It is not transitive
   5. No, again, not always transitive
   6. No, not always symmetric
   7. True
   8. True
   9. True
*** MON
#+BEGIN_SRC emacs-lisp :results output
(defun build-partition-set-table (m &optional n)
  (let* ((count (if (null n) 20 n))
         (bound (* count m)))
    (loop for i from 0 below m
          do (princ "[ ")
          (loop for j from (+ (- bound) i) to (+ bound i) by m
                do (princ j)
                (princ " "))
          (princ "]\n"))))

(build-partition-set-table '5)
#+END_SRC

#+RESULTS:
: [ -100 -95 -90 -85 -80 -75 -70 -65 -60 -55 -50 -45 -40 -35 -30 -25 -20 -15 -10 -5 0 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 ]
: [ -99 -94 -89 -84 -79 -74 -69 -64 -59 -54 -49 -44 -39 -34 -29 -24 -19 -14 -9 -4 1 6 11 16 21 26 31 36 41 46 51 56 61 66 71 76 81 86 91 96 101 ]
: [ -98 -93 -88 -83 -78 -73 -68 -63 -58 -53 -48 -43 -38 -33 -28 -23 -18 -13 -8 -3 2 7 12 17 22 27 32 37 42 47 52 57 62 67 72 77 82 87 92 97 102 ]
: [ -97 -92 -87 -82 -77 -72 -67 -62 -57 -52 -47 -42 -37 -32 -27 -22 -17 -12 -7 -2 3 8 13 18 23 28 33 38 43 48 53 58 63 68 73 78 83 88 93 98 103 ]
: [ -96 -91 -86 -81 -76 -71 -66 -61 -56 -51 -46 -41 -36 -31 -26 -21 -16 -11 -6 -1 4 9 14 19 24 29 34 39 44 49 54 59 64 69 74 79 84 89 94 99 104 ]
* Week 5 JKL
** Reading
   :LOGBOOK:
   CLOCK: [2017-10-16 Mon 21:10]--[2017-10-16 Mon 21:15] =>  0:05
   :END:
** Week 5 Day One
   :LOGBOOK:
   CLOCK: [2017-10-17 Tue 10:16]
   :END:
*** ICE
**** How Would You?
#+BEGIN_SRC emacs-lisp :results raw
(defun shuffle-ice (set1 set2)
   (let (v sequence)
   (make-sequence (loop for i across set1
         for j across set2 
         (append (list i j))))))


(shuffle-ice [A B C] [1 2 3])
#+END_SRC

#+RESULTS:
shuffle-ice

** Week 5 Day Two
** DONE JKM
   CLOSED: [2017-10-16 Mon 21:40]
*** DONE QAM
    CLOSED: [2017-10-16 Mon 21:19]
    :LOGBOOK:
    CLOCK: [2017-10-16 Mon 21:15]--[2017-10-16 Mon 21:19] =>  0:04
    :END:
    * This will be the product rule and the sum rule. With a set of 5 long-sleeve and 3 short-sleeve, applying the sum rule, we get 8 shirts. 
      We can now combined this sum with the set of pants using the product rule, giving us 1 * 8 = 8 different outfits.
    * So we take the original 8 shirts * 2 pants * 10 ties giving us 160 outfits.
    * The multiplication principle.
*** DONE REX
    CLOSED: [2017-10-16 Mon 21:24]
    :LOGBOOK:
    CLOCK: [2017-10-16 Mon 21:19]--[2017-10-16 Mon 21:24] =>  0:05
    :END:

    The sum should be adjusted to be the length of the set A \cup B 
*** DONE QCV
    CLOSED: [2017-10-16 Mon 21:29]
    :LOGBOOK:
    CLOCK: [2017-10-16 Mon 21:25]--[2017-10-16 Mon 21:29] =>  0:04
    :END:
    If set A is size n, and set B is size m, then there are set m^n functions in A \rarr B.
    So if set A is size 3, and set B is size 5, then there are 5^3 functions, or 125.
*** DONE RFC
    CLOSED: [2017-10-16 Mon 21:39]
    :LOGBOOK:
    CLOCK: [2017-10-16 Mon 21:30]--[2017-10-16 Mon 21:33] =>  0:03
    :END:
    If set A is size n and set B is size m, then the amount of one-to-one functions is
    m!/(m-n)! so 120/2 = 60 one-to-one functions.
*** DONE QCZ
    CLOSED: [2017-10-16 Mon 21:39]
    :LOGBOOK:
    CLOCK: [2017-10-16 Mon 21:34]--[2017-10-16 Mon 21:39] =>  0:05
    :END:
    There are no onto functions from a set X of size 3 and a set Y of size 5. 
    An onto function is surjective, which means that every element in Y is mapped to from X.
    Because size of X \lt Y, it cannot map to every element in Y, therefore, there are no surjective (onto) functions.
** TODO JKN

